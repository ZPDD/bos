     1                                  org 0x70000000
     2                                  bits 64
     3 00000000 E9C4090000              jmp ENTRY
     4 00000005 90                      nop
     5 00000006 90                      nop
     6                                  
     7                                  ;*******************************************************************************
     8                                  ;*  PROGRAM HEADER
     9                                  ;*******************************************************************************
    10 00000007 424F5353                dd 0x53534F42           ; magic number
    11                                  
    12                                  
    13                                  ;*******************************************************************************
    14                                  ;*  PROGRAM DATA
    15                                  ;*******************************************************************************
    16 0000000B 0000                    x dw 0
    17 0000000D 0000                    y dw 0
    18 0000000F 01                      direction db 1      ; 1=down, 0=up
    19 00000010 0000                    floor dw 0
    20 00000012 0100                    move_rate dw 1
    21 00000014 0000                    start_x dw 0
    22 00000016 0000                    start_y dw 0
    23 00000018 1900000000000000        wait_time_ms    dq 25      ; millis to wait
    24                                  
    25                                  ;*******************************************************************************
    26                                  ;*  INCLUDED FILES
    27                                  ;*******************************************************************************
    28                                  %include "lib_app.asm"
    29                              <1> ;*******************************************************************************
    30                              <1> ;	LIBRARY - FOR APPLICATIONS
    31                              <1> ;
    32                              <1> ; A library file with common routines that would be used in applications.
    33                              <1> ;
    34                              <1> ; Copyright (c) 2016-2020, David Borsato
    35                              <1> ; Created: Nov 7, 2018 by David Borsato
    36                              <1> ;*******************************************************************************
    37                              <1> 
    38                              <1> FONT1.FULL.BLOCK 	equ 9608
    39                              <1> TCP_SIG_HDR_Size	equ 32
    40                              <1> 
    41                              <1> ;;
    42                              <1> ;; GLOBAL VARIABLES
    43                              <1> ;;
    44 00000020 0010000000000000    <1> PAGE_SZ 		dq 0x1000 		; system page size (4K)
    45                              <1> 
    46                              <1> ; GUI
    47 00000028 0000                <1> BPP 			dw 0			; bits per pixel
    48 0000002A 0000                <1> BytesPP			dw 0			; bytes per pixel
    49 0000002C 0200                <1> CH_NUM 			dw 2			;
    50 0000002E 00                  <1> GUI				db 0			; GUI mode of system
    51 0000002F 0000                <1> GUI_X 			dw 0			; X res
    52 00000031 0000                <1> GUI_Y 			dw 0 			; Y res
    53 00000033 0000                <1> GUI_CH_W		dw 0			; char width
    54 00000035 0000                <1> GUI_CH_H		dw 0			; char height
    55 00000037 0000                <1> LINE_NO 		dw 0			; tracks what line number to print on
    56 00000039 1500                <1> LINE_MAX_TXT	dw 21			; maximum lines in text mode (21 default)
    57 0000003B 1500                <1> LINE_MAX_GUI	dw 21			; maximum lines in gui mode (21 default)
    58 0000003D 0000                <1> YPITCH 			dw 0
    59 0000003F 0000000000000000    <1> VID_ADDR		dq 0			; base video memory address
    60                              <1> 
    61                              <1> ; Network config
    62 00000047 0000000000000000    <1> CID 			dq 0			; connection ID
    63 0000004F 0000                <1> PORT 			dw 0
    64 00000051 0000000000000000    <1> RCV_BUFF		dq 0			; memory receive buffer
    65 00000059 00000000            <1> RCV_BUFF_SZ		dd 0 			; size of receive buffer (1,040,675)
    66 0000005D 00000000            <1> RCV_BUFF_PTR	dd 0			; memory pointer into RCV_BUFF
    67                              <1> 
    68                              <1> 
    69                              <1> ;*******************************************************************************
    70                              <1> ;*                        E R R O R   H A N D L I N G
    71                              <1> ;*******************************************************************************
    72 00000061 4552524F523A20436F- <1> msgErrOpen			db 'ERROR: Could not open network port.',0
    72 0000006A 756C64206E6F74206F- <1>
    72 00000073 70656E206E6574776F- <1>
    72 0000007C 726B20706F72742E00  <1>
    73 00000085 4552524F523A204E6F- <1> msgNoMem			db 'ERROR: Not enough memory!',0
    73 0000008E 7420656E6F75676820- <1>
    73 00000097 6D656D6F72792100    <1>
    74 0000009F 4552524F523A204E6F- <1> msgNoMemNet			db 'ERROR: Not enough memory for send and receive buffers!',0
    74 000000A8 7420656E6F75676820- <1>
    74 000000B1 6D656D6F727920666F- <1>
    74 000000BA 722073656E6420616E- <1>
    74 000000C3 642072656365697665- <1>
    74 000000CC 206275666665727321- <1>
    74 000000D5 00                  <1>
    75                              <1> 
    76                              <1> Error_no_memory_network:
    77 000000D6 48BE-               <1> 	mov rsi,msgNoMemNet
    77 000000D8 [9F00000000000000]  <1>
    78 000000E0 EB18                <1> 	jmp Error_handler
    79                              <1> 
    80                              <1> Error_no_memory:
    81 000000E2 48BE-               <1> 	mov rsi,msgNoMem
    81 000000E4 [8500000000000000]  <1>
    82 000000EC EB0C                <1> 	jmp Error_handler
    83                              <1> 
    84                              <1> Error_open_port:
    85 000000EE 48BE-               <1> 	mov rsi,msgErrOpen
    85 000000F0 [6100000000000000]  <1>
    86 000000F8 EB00                <1> 	jmp Error_handler
    87                              <1> 
    88                              <1> 
    89                              <1> ; IN:	RSI = Error message
    90                              <1> Error_handler:
    91 000000FA 6631C0              <1> 	xor ax,ax 				; to X to 0
    92 000000FD 66FF0425[37000000]  <1> 	inc word [LINE_NO]
    93 00000105 E87E040000          <1> 	call print_ln
    94                              <1> 
    95                              <1> Exit:
    96 0000010A BA00000000          <1> 	mov rdx,0x0				; stop process
    97 0000010F CDFF                <1> 	int 0xFF
    98                              <1> 
    99                              <1> 
   100                              <1> ;*******************************************************************************
   101                              <1> ;*                          P R O C E D U R E S
   102                              <1> ;*******************************************************************************
   103                              <1> 
   104                              <1> ;*******************************************************************************
   105                              <1> ; Allocates memory from system.
   106                              <1> ; IN:	RAX:	memory size, in bytes, to allocate
   107                              <1> ; OUT:	 BL:	return code; 0=success, anything else is an error
   108                              <1> ;		RAX:	memory address of memory allocated
   109                              <1> ;*******************************************************************************
   110                              <1> alloc:
   111 00000111 52                  <1> 	push rdx
   112 00000112 BA21020000          <1> 	mov rdx,0x221
   113 00000117 CDFF                <1> 	int 0xFF
   114 00000119 5A                  <1> 	pop rdx
   115 0000011A 80FB00              <1> 	cmp bl,0
   116 0000011D 75B7                <1> 	jnz Error_no_memory_network
   117 0000011F C3                  <1> ret
   118                              <1> 
   119                              <1> clrscr:
   120                              <1> clr_scr:
   121                              <1> clear_screen:
   122 00000120 52                  <1> 	push rdx
   123 00000121 66C70425[37000000]- <1> 	mov word [LINE_NO],0x0		; reset line number
   123 00000129 0000                <1>
   124                              <1> 
   125 0000012B 803C25[2E000000]00  <1> 	cmp byte [GUI],0
   126 00000133 7509                <1> 	jnz .Clear_gui
   127                              <1> 
   128 00000135 BA00030000          <1> 	mov rdx,0x300
   129 0000013A CDFF                <1> 	int 0xFF
   130                              <1> 
   131 0000013C EB44                <1> 	jmp .Done
   132                              <1> 
   133                              <1> .Clear_gui:
   134 0000013E 51                  <1> 	push rcx
   135 0000013F 52                  <1> 	push rdx
   136 00000140 4150                <1> 	push r8
   137 00000142 4151                <1> 	push r9
   138 00000144 4152                <1> 	push r10
   139 00000146 4153                <1> 	push r11
   140                              <1> 
   141 00000148 4D31D2              <1> 	xor r10,r10
   142 0000014B 4D31DB              <1> 	xor r11,r11
   143                              <1> 
   144                              <1> 	; Clear screen
   145                              <1> 	; IN:	 R8 = starting X (left)
   146                              <1> 	;		 R9 = starting Y (top)
   147                              <1> 	;		R10 = width
   148                              <1> 	;		R11 = height
   149                              <1> 	;		ECX = color
   150                              <1> 	; 		RDX = 0x126
   151 0000014E 41B800000000        <1> 	mov r8,0
   152 00000154 41B900000000        <1> 	mov r9,0
   153 0000015A 66448B1425-         <1> 	mov r10w,[GUI_X]
   153 0000015F [2F000000]          <1>
   154 00000163 66448B1C25-         <1> 	mov r11w,[GUI_Y]
   154 00000168 [31000000]          <1>
   155 0000016C B900000000          <1> 	mov ecx, 0x0				; black
   156 00000171 BA26010000          <1> 	mov rdx, 0x126				; draw full box
   157 00000176 CDFF                <1> 	int 0xFF
   158                              <1> 
   159 00000178 415B                <1> 	pop r11
   160 0000017A 415A                <1> 	pop r10
   161 0000017C 4159                <1> 	pop r9
   162 0000017E 4158                <1> 	pop r8
   163 00000180 5A                  <1> 	pop rdx
   164 00000181 59                  <1> 	pop rcx
   165                              <1> 
   166                              <1> .Done:
   167 00000182 5A                  <1> 	pop rdx
   168 00000183 C3                  <1> ret
   169                              <1> 
   170                              <1> 
   171                              <1> ;******************************************************************************
   172                              <1> ; Clears one character on the screen. NOTE: This only works in GUI mode.
   173                              <1> ; IN:	AL = X
   174                              <1> ;		AH = Y
   175                              <1> ;******************************************************************************
   176                              <1> clear_screen_ch:
   177 00000184 803C25[2E000000]00  <1> cmp byte [GUI],0
   178 0000018C 740E                <1> jz .Return
   179                              <1> 
   180                              <1> ;;
   181                              <1> ;; NOTE: rework this routine to use CH_W & CH_H instead, then draw a small box.
   182                              <1> ;;
   183 0000018E 52                  <1> 	push rdx
   184 0000018F B900000000          <1> 	mov ecx,0x000000 		; black
   185 00000194 BA02040000          <1> 	mov rdx,0x402
   186 00000199 CDFF                <1> 	int 0xFF
   187 0000019B 5A                  <1> 	pop rdx
   188                              <1> .Return:
   189 0000019C C3                  <1> ret
   190 0000019D 88250000            <1> .char 		dw 9608,0
   191                              <1> 
   192                              <1> 
   193                              <1> ;******************************************************************************
   194                              <1> ; Copies physical memory from one location to another. Leaves RDI and RSI intact.
   195                              <1> ; IN:	RSI = source location
   196                              <1> ;		RDI = destination location
   197                              <1> ; 		RAX = number of bytes to copy
   198                              <1> ; OUT:	RSI & RDI updated with number of bytes.
   199                              <1> ;******************************************************************************
   200                              <1> cpymem:
   201                              <1> cpy_mem:
   202 000001A1 50                  <1> 	push rax
   203 000001A2 51                  <1> 	push rcx
   204 000001A3 52                  <1> 	push rdx
   205                              <1> 
   206 000001A4 B908000000          <1> 	mov rcx,8
   207 000001A9 4831D2              <1> 	xor rdx,rdx
   208 000001AC 48F7F1              <1> 	div rcx
   209 000001AF 4889C1              <1> 	mov rcx,rax
   210 000001B2 FC                  <1> 	cld
   211 000001B3 F348A5              <1> 	rep movsq
   212 000001B6 4889D1              <1> 	mov rcx,rdx
   213 000001B9 F3A4                <1> 	rep movsb
   214                              <1> 
   215 000001BB 5A                  <1> 	pop rdx
   216 000001BC 59                  <1> 	pop rcx
   217 000001BD 58                  <1> 	pop rax
   218 000001BE C3                  <1> ret
   219                              <1> 
   220                              <1> 
   221                              <1> ;******************************************************************************
   222                              <1> ; Deallocates memory.
   223                              <1> ; IN:	RAX = memory location
   224                              <1> ; 		RCX = number of bytes to deallocate
   225                              <1> ; OUT:	---
   226                              <1> ;******************************************************************************
   227                              <1> dalloc:
   228 000001BF 52                  <1> 	push rdx
   229 000001C0 BA22020000          <1> 	mov rdx,0x222
   230 000001C5 CDFF                <1> 	int 0xFF
   231 000001C7 5A                  <1> 	pop rdx
   232 000001C8 C3                  <1> ret
   233                              <1> 
   234                              <1> 
   235                              <1> ;******************************************************************************
   236                              <1> ; Returns the PID of the currently running program.
   237                              <1> ; IN:	---
   238                              <1> ; OUT:	 AX = PID
   239                              <1> ;******************************************************************************
   240                              <1> get_curr_pid:
   241 000001C9 52                  <1> 	push rdx
   242 000001CA 4831C0              <1> 	xor rax,rax
   243 000001CD BA00020000          <1> 	mov rdx, 0x200
   244 000001D2 5A                  <1> 	pop rdx
   245 000001D3 C3                  <1> ret
   246                              <1> 
   247                              <1> 
   248                              <1> ;******************************************************************************
   249                              <1> ; Checks if system is in GUI mode or not. If in GUI mode then initializes
   250                              <1> ; environment and variables.
   251                              <1> ;
   252                              <1> ; IN:	---
   253                              <1> ; OUT:	GUI; 0=text mode, 1=graphic mode (aka GUI)
   254                              <1> ;			 ::  If GUI is enabled, then ::
   255                              <1> ;		GUI_X; 		X resolution of screen
   256                              <1> ;		GUI_Y; 		Y resolution of screen
   257                              <1> ;		GUI_CH_W;	width of a character
   258                              <1> ;		GUI_CH_H;	height of a character
   259                              <1> ;******************************************************************************
   260                              <1> get_gui_mode:
   261 000001D4 50                  <1> 	push rax
   262 000001D5 52                  <1> 	push rdx
   263                              <1> 
   264 000001D6 BA0D010000          <1> 	mov rdx,0x10D
   265 000001DB CDFF                <1> 	int 0xFF
   266 000001DD 880425[2E000000]    <1> 	mov byte [GUI], al
   267                              <1> 
   268                              <1> ; If GUI is enabled then get; screen resolution, character sizes, max. lines,
   269                              <1> ; bits per pixel, bytes per pixel.
   270 000001E4 3C00                <1> 	cmp al,0
   271 000001E6 0F84BC000000        <1> 	jz .Done
   272 000001EC 53                  <1> 		push rbx
   273 000001ED 4152                <1> 		push r10
   274                              <1> 
   275 000001EF BA04010000          <1> 			mov rdx,0x104
   276 000001F4 CDFF                <1> 			int 0xFF
   277 000001F6 66890425[2F000000]  <1> 			mov word [GUI_X],ax
   278 000001FE BA05010000          <1> 			mov rdx,0x105
   279 00000203 CDFF                <1> 			int 0xFF
   280 00000205 66890425[31000000]  <1> 			mov word [GUI_Y],ax
   281 0000020D BA01010000          <1> 			mov rdx,0x101
   282 00000212 41BA20000000        <1> 			mov r10,' '
   283 00000218 CDFF                <1> 			int 0xFF
   284 0000021A 66890425[33000000]  <1> 			mov [GUI_CH_W],ax
   285 00000222 66891C25[35000000]  <1> 			mov [GUI_CH_H],bx
   286 0000022A 668B0425[31000000]  <1> 			mov ax,[GUI_Y]
   287 00000232 6629D8              <1> 			sub ax,bx
   288 00000235 6629D8              <1> 			sub ax,bx
   289 00000238 66890425[31000000]  <1> 			mov [GUI_Y],ax				; reset Y so that CMD box is not cleared
   290                              <1> 
   291 00000240 31C0                <1> 			xor eax,eax
   292 00000242 BA06010000          <1> 			mov rdx, 0x106 				; get bits per pixel, returns to AX
   293 00000247 CDFF                <1> 			int 0xFF
   294 00000249 66890425[28000000]  <1> 			mov word [BPP], ax
   295                              <1> 
   296 00000251 BB08000000          <1> 			mov ebx,8					; get bytes per pixel
   297 00000256 31D2                <1> 			xor edx,edx
   298 00000258 66F7F3              <1> 			div bx
   299 0000025B 66890425[2A000000]  <1> 			mov word [BytesPP],ax
   300                              <1> 
   301 00000263 BA02010000          <1> 			mov edx, 0x102				; get YPITCH
   302 00000268 CDFF                <1> 			int 0xFF
   303 0000026A 66890425[3D000000]  <1> 			mov word [YPITCH], ax
   304                              <1> 
   305                              <1> 			; Calc max. printed lines on screen
   306 00000272 668B0425[31000000]  <1> 			mov ax,[GUI_Y]
   307 0000027A 668B1C25[35000000]  <1> 			mov bx,[GUI_CH_H]
   308 00000282 6629D8              <1> 			sub ax,bx
   309 00000285 6629D8              <1> 			sub ax,bx
   310 00000288 4831D2              <1> 			xor rdx,rdx
   311 0000028B 66F7F3              <1> 			div bx
   312 0000028E 66890425[3B000000]  <1> 			mov [LINE_MAX_GUI],ax
   313                              <1> 
   314 00000296 BA0F010000          <1> 			mov edx,0x10F 				; get base video address
   315 0000029B CDFF                <1> 			int 0xFF
   316 0000029D 48890425[3F000000]  <1> 			mov [VID_ADDR],rax
   317 000002A5 415A                <1> 		pop r10
   318 000002A7 5B                  <1> 		pop rbx
   319                              <1> 
   320                              <1> .Done:
   321 000002A8 5A                  <1> 	pop rdx
   322 000002A9 58                  <1> 	pop rax
   323 000002AA C3                  <1> ret
   324                              <1> 
   325                              <1> 
   326                              <1> ;******************************************************************************
   327                              <1> ; Converts X coordinate into a GUI X coordinate.
   328                              <1> ; IN:	AL = X coordinate
   329                              <1> ;		GUI_CH_W
   330                              <1> ; OUT:	AX = X coordinate
   331                              <1> ;******************************************************************************
   332                              <1> get_gui_x:
   333 000002AB 53                  <1> 	push rbx
   334 000002AC 52                  <1> 	push rdx
   335 000002AD 4831D2              <1> 	xor rdx,rdx
   336 000002B0 4831DB              <1> 	xor rbx,rbx
   337 000002B3 6625FF00            <1> 	and ax,0x00FF 			; isolate X coordinate
   338 000002B7 668B1C25[33000000]  <1> 	mov bx,[GUI_CH_W]
   339 000002BF 66F7E3              <1> 	mul bx
   340 000002C2 5A                  <1> 	pop rdx
   341 000002C3 5B                  <1> 	pop rbx
   342 000002C4 C3                  <1> ret
   343                              <1> 
   344                              <1> 
   345                              <1> ;******************************************************************************
   346                              <1> ; Converts Y coordinate into a GUI Y coordinate.
   347                              <1> ; IN:	BL = Y coordinate
   348                              <1> ;		GUI_CH_H
   349                              <1> ; OUT:	BX = Y coordinate
   350                              <1> ;******************************************************************************
   351                              <1> get_gui_y:
   352 000002C5 50                  <1> 	push rax
   353 000002C6 4831C0              <1> 	xor rax,rax
   354 000002C9 4831D2              <1> 	xor rdx,rdx
   355 000002CC 668B0425[35000000]  <1> 	mov ax,[GUI_CH_H]
   356 000002D4 66F7E3              <1> 	mul bx
   357 000002D7 6689C3              <1> 	mov bx,ax					; return Y
   358 000002DA 58                  <1> 	pop rax
   359 000002DB C3                  <1> ret
   360                              <1> 
   361                              <1> 
   362                              <1> ;******************************************************************************
   363                              <1> ; Returns a PID for a specified program name
   364                              <1> ; IN:	RSI = program name
   365                              <1> ; OUT:	 BX = PID
   366                              <1> ;******************************************************************************
   367                              <1> get_pid:
   368 000002DC 52                  <1> 	push rdx
   369 000002DD BA03040000          <1> 	mov rdx,0x403
   370 000002E2 CDFF                <1> 	int 0xFF
   371 000002E4 5A                  <1> 	pop rdx
   372 000002E5 C3                  <1> ret
   373                              <1> 
   374                              <1> ;******************************************************************************
   375                              <1> ; Returns current tick counter.
   376                              <1> ; IN:	---
   377                              <1> ; OUT:	RAX = tick counter
   378                              <1> ;******************************************************************************
   379                              <1> get_tick_ctr:
   380 000002E6 52                  <1> 	push rdx
   381 000002E7 BA0E000000          <1> 	mov rdx,0xE
   382 000002EC CDFF                <1> 	int 0xFF
   383 000002EE 5A                  <1> 	pop rdx
   384 000002EF C3                  <1> ret
   385                              <1> 
   386                              <1> ;******************************************************************************
   387                              <1> ; Returns millisecond and sub-millisecond time since the system has been up.
   388                              <1> ; IN:	---
   389                              <1> ; OUT:	RAX = ms (upper QWORD), sub ms (lower QWORD)
   390                              <1> ;******************************************************************************
   391                              <1> get_time_exact:
   392 000002F0 53                  <1> 	push rbx
   393 000002F1 52                  <1> 	push rdx
   394 000002F2 BA0C000000          <1> 	mov rdx,0xC
   395 000002F7 CDFF                <1> 	int 0xFF
   396 000002F9 48C1E020            <1> 	shl rax,32
   397 000002FD 4809D8              <1> 	or rax,rbx
   398 00000300 5A                  <1> 	pop rdx
   399 00000301 5B                  <1> 	pop rbx
   400 00000302 C3                  <1> ret
   401                              <1> 
   402                              <1> ;******************************************************************************
   403                              <1> ; Returns the current value of the processorâ€™s time-stamp counter. The counter
   404                              <1> ; is cycles, not time!!
   405                              <1> ; IN:	---
   406                              <1> ; OUT:	RAX = cycles
   407                              <1> ;******************************************************************************
   408                              <1> get_rdt_cycle:
   409 00000303 52                  <1> 	push rdx
   410 00000304 31C0                <1> 	xor eax, eax
   411 00000306 0FA2                <1> 	cpuid
   412 00000308 31C0                <1> 	xor eax, eax
   413 0000030A 0FA2                <1> 	cpuid
   414 0000030C 31C0                <1> 	xor eax, eax
   415 0000030E 0FA2                <1> 	cpuid
   416 00000310 0F31                <1> 	rdtsc
   417 00000312 48C1E220            <1> 	shl rdx,32
   418 00000316 4809D0              <1> 	or rax,rdx
   419 00000319 5A                  <1> 	pop rdx
   420 0000031A C3                  <1> ret
   421                              <1> 
   422                              <1> 
   423                              <1> ;******************************************************************************
   424                              <1> ;	Initialize GUI environment.
   425                              <1> ;******************************************************************************
   426                              <1> gui_init:
   427 0000031B E9B4FEFFFF          <1> 	jmp get_gui_mode
   428                              <1> 
   429                              <1> 
   430                              <1> ;******************************************************************************
   431                              <1> ;	hexToChar
   432                              <1> ;		- converts a HEX byte into character string.  BH will hold the high
   433                              <1> ;		  order byte and BL will hold the low order byte.
   434                              <1> ;	param/		BL = HEX byte to convert (e.g. DB)
   435                              <1> ;	returns/	BH = high order byte (e.g. D)
   436                              <1> ;	returns/	BL = low order byte (e.g. B)
   437                              <1> ;******************************************************************************
   438                              <1> hexToChar:
   439 00000320 50                  <1> 	push rax
   440                              <1> 
   441 00000321 31C0                <1> 	xor eax, eax 					; initialize EAX for use
   442 00000323 30FF                <1> 	xor bh, bh						; initialize BH
   443                              <1> 
   444 00000325 88D8                <1> 	mov al, bl	 					; copy BL to AL
   445                              <1> 
   446 00000327 3C10                <1> 	cmp al, 0x10 					; if less then 0x10h, then we don't need
   447 00000329 7215                <1> 	jb  .Convert_lower_bits			; to worry about the high order bits
   448                              <1> 
   449 0000032B 53                  <1> 	push rbx 						; store on stack for later
   450 0000032C 31DB                <1> 	xor ebx, ebx 					; initialize EBX for use
   451                              <1> 
   452 0000032E C0E804              <1> 	shr al, 4						; move bits 5-8 over 1 nibble to get character
   453 00000331 3C0A                <1> 	cmp al, 0xA
   454 00000333 7C04                <1> 	jl  .High_0_to_9
   455 00000335 0437                <1> 	add al, 0x37
   456 00000337 EB02                <1> 	jmp .Add_to_BH
   457                              <1> .High_0_to_9:
   458 00000339 0430                <1> 	add al, 0x30
   459                              <1> 
   460                              <1> .Add_to_BH:
   461 0000033B 88C7                <1> 	mov bh, al						; put in BH
   462                              <1> 
   463 0000033D 58                  <1> 	pop rax							; retrieve orignal number from stack
   464 0000033E 240F                <1> 	and al, 1111b 					; mask out the upper nibble in AL
   465                              <1> 
   466                              <1> .Convert_lower_bits:
   467 00000340 3C0A                <1> 	cmp al, 0xA
   468 00000342 7204                <1> 	jb  .Lower_0_to_9
   469 00000344 0437                <1> 	add al, 0x37
   470 00000346 EB02                <1> 	jmp .Add_to_BL
   471                              <1> 
   472                              <1> .Lower_0_to_9:
   473 00000348 0430                <1> 	add al, 0x30
   474                              <1> 
   475                              <1> .Add_to_BL:
   476 0000034A 88C3                <1> 	mov bl, al
   477                              <1> 
   478                              <1> .Done:
   479 0000034C 58                  <1> 	pop rax
   480 0000034D C3                  <1> ret
   481                              <1> 
   482                              <1> 
   483                              <1> ;******************************************************************************
   484                              <1> ; Converts a 4 bytes hex number to an IP address string.
   485                              <1> ; NOTES:
   486                              <1> ;		* This does not do any error checking, that is up to the programmer.
   487                              <1> ;		* This will increment RDI.
   488                              <1> ; IN:	EAX = hex number
   489                              <1> ; 		RDI = memory location of string
   490                              <1> ;******************************************************************************
   491                              <1> hexToIPString:
   492 0000034E 50                  <1> 	push rax
   493 0000034F 53                  <1> 	push rbx
   494                              <1> 	;
   495 00000350 4831DB              <1> 	xor rbx,rbx
   496 00000353 88C3                <1> 	mov bl, al	 	; fourth octet
   497 00000355 E890010000          <1> 	call intToString_incr_rbx
   498 0000035A C6072E              <1> 	mov byte [rdi], '.'
   499 0000035D 48FFC7              <1> 	inc rdi
   500 00000360 48C1E808            <1> 	shr rax,8
   501                              <1> 
   502 00000364 88C3                <1> 	mov bl, al		; third octet
   503 00000366 E87F010000          <1> 	call intToString_incr_rbx
   504 0000036B C6072E              <1> 	mov byte [rdi], '.'
   505 0000036E 48FFC7              <1> 	inc rdi
   506 00000371 48C1E808            <1> 	shr rax,8
   507                              <1> 
   508 00000375 88C3                <1> 	mov bl, al		; second octet
   509 00000377 E86E010000          <1> 	call intToString_incr_rbx
   510 0000037C C6072E              <1> 	mov byte [rdi], '.'
   511 0000037F 48FFC7              <1> 	inc rdi
   512 00000382 48C1E808            <1> 	shr rax,8
   513                              <1> 
   514 00000386 88C3                <1> 	mov bl, al		; first octet
   515 00000388 E85D010000          <1> 	call intToString_incr_rbx
   516                              <1> 
   517 0000038D 5B                  <1> 	pop rbx
   518 0000038E 58                  <1> 	pop rax
   519 0000038F C3                  <1> ret
   520                              <1> 
   521                              <1> ;	Same as hexToIPString but uses EBX instead
   522                              <1> hexToIPString_ebx:
   523 00000390 50                  <1> 	push rax
   524 00000391 89D8                <1> 	mov eax,ebx
   525 00000393 E8B6FFFFFF          <1> 	call hexToIPString
   526 00000398 58                  <1> 	pop rax
   527 00000399 C3                  <1> ret
   528                              <1> 
   529                              <1> 
   530                              <1> ;	Calls the function below, but allows the programmer to use EBX as
   531                              <1> ;	the parameter instead of EAX.
   532                              <1> ;	IN:	EBX = hex number
   533                              <1> ;		EDI = address pointer to put string
   534                              <1> hexToString_ebx:
   535 0000039A 50                  <1> 	push rax
   536 0000039B 4889D8              <1> 	mov rax, rbx
   537 0000039E E802000000          <1> 	call hexToString
   538 000003A3 58                  <1> 	pop rax
   539 000003A4 C3                  <1> ret
   540                              <1> 
   541                              <1> ;******************************************************************************
   542                              <1> ;	hexToString
   543                              <1> ;		- converts a hex number to string so that you can print it to the
   544                              <1> ;		  screen.
   545                              <1> ;	param/		RAX = hex number
   546                              <1> ;	param/		RDI = address pointer to put string
   547                              <1> ;******************************************************************************
   548                              <1> hexToString:
   549 000003A5 50                  <1> 	push rax
   550 000003A6 53                  <1> 	push rbx
   551 000003A7 57                  <1> 	push rdi
   552                              <1> 
   553 000003A8 4883F800            <1> 	cmp rax, 0					; first check if value is zero
   554 000003AC 742C                <1> 	je  .Return_zero			; if so, then just return a zero and exit
   555                              <1> 
   556 000003AE 4831DB              <1> 	xor rbx, rbx				; initialize EBX to zeros
   557 000003B1 53                  <1> 	push rbx 					; push zeros to stack to act as a terminator
   558                              <1> 
   559                              <1> .Loop1:
   560 000003B2 4883F800            <1> 	cmp rax, 0					; if EAX=0 then there is nothing left to convert
   561 000003B6 7413                <1> 	je .Save_string_to_var 		; exit and build string
   562                              <1> 
   563 000003B8 4889C3              <1> 	mov rbx, rax				; create a working copy
   564 000003BB 4883E30F            <1> 	and rbx, 1111b 				; get the last nibble
   565 000003BF E85CFFFFFF          <1> 	call hexToChar				; convert to ASCII character
   566 000003C4 53                  <1> 	push rbx					; save ASCII values on stack
   567 000003C5 48C1E804            <1> 	shr rax, 4
   568 000003C9 EBE7                <1> 	jmp .Loop1
   569                              <1> 
   570                              <1> .Save_string_to_var:
   571 000003CB 5B                  <1> 	pop rbx
   572                              <1> 
   573                              <1> .Loop2:
   574 000003CC 4883FB00            <1> 	cmp rbx, 0					; terminator found, exit loop
   575 000003D0 740E                <1> 	je  .Done
   576 000003D2 881F                <1> 	mov [rdi], bl 				; copy to address pointer
   577 000003D4 48FFC7              <1> 	inc rdi						; move EDI forward
   578 000003D7 5B                  <1> 	pop rbx
   579 000003D8 EBF2                <1> 	jmp .Loop2
   580                              <1> 
   581                              <1> .Return_zero:
   582 000003DA C60730              <1> 	mov [rdi], byte '0'			; ASCII value of zero
   583 000003DD 48FFC7              <1> 	inc rdi
   584                              <1> 
   585                              <1> .Done:
   586 000003E0 C60700              <1> 	mov [rdi], byte 0			; add null terminator
   587 000003E3 5F                  <1> 	pop rdi
   588 000003E4 5B                  <1> 	pop rbx
   589 000003E5 58                  <1> 	pop rax
   590 000003E6 C3                  <1> ret
   591                              <1> 
   592                              <1> 
   593                              <1> inc_line:
   594 000003E7 50                  <1> 	push rax
   595                              <1> 
   596 000003E8 66FF0425[37000000]  <1> 	inc word [LINE_NO]
   597                              <1> 
   598                              <1> ; Check if at end of the screen
   599 000003F0 803C25[2E000000]00  <1> 	cmp byte [GUI],0
   600 000003F8 750A                <1> 	jnz .GUI
   601 000003FA 668B0425[39000000]  <1> 		mov ax,[LINE_MAX_TXT]
   602 00000402 EB08                <1> 		jmp .Chk_line
   603                              <1> 	.GUI:
   604 00000404 668B0425[3B000000]  <1> 		mov ax,[LINE_MAX_GUI]
   605                              <1> 	.Chk_line:
   606                              <1> 
   607 0000040C 66390425[37000000]  <1> 	cmp word [LINE_NO],ax
   608 00000414 7702                <1> 	ja .Reset
   609                              <1> 
   610                              <1> .Done:
   611 00000416 58                  <1> 	pop rax
   612 00000417 C3                  <1> ret
   613                              <1> .Reset:
   614 00000418 66C70425[37000000]- <1> 	mov word [LINE_NO],0
   614 00000420 0000                <1>
   615 00000422 E8F9FCFFFF          <1> 	call clear_screen
   616 00000427 EBED                <1> 	jmp .Done
   617                              <1> 
   618                              <1> init_line:
   619 00000429 E8B9FFFFFF          <1> 	call inc_line
   620 0000042E 668B0425[37000000]  <1> 	mov ax,[LINE_NO]
   621 00000436 66C1E008            <1> 	shl ax,8
   622 0000043A C3                  <1> ret
   623                              <1> 
   624                              <1> ;******************************************************************************
   625                              <1> ; Initialize environment.
   626                              <1> ;******************************************************************************
   627                              <1> initialize:
   628 0000043B E894FDFFFF          <1> 	call get_gui_mode
   629 00000440 C3                  <1> ret
   630                              <1> 
   631                              <1> 
   632                              <1> ;******************************************************************************
   633                              <1> ;	IntToHex
   634                              <1> ;		- converts a decimal number to a hex number
   635                              <1> ;	IN:		RBX = original decimal number
   636                              <1> ;	OUT:	RBX = converted hex number
   637                              <1> ;******************************************************************************
   638                              <1> IntToHex:
   639 00000441 50                  <1> 	push rax 				; working digit
   640 00000442 51                  <1> 	push rcx 				; multiplier
   641 00000443 52                  <1> 	push rdx
   642 00000444 4150                <1> 	push r8 				; running number
   643                              <1> 
   644 00000446 4831C0              <1> 	xor rax, rax
   645 00000449 4831D2              <1> 	xor rdx, rdx
   646 0000044C 4889D8              <1> 	mov rax, rbx
   647 0000044F B90A000000          <1> 	mov rcx, 0xA
   648                              <1> 
   649 00000454 4883E00F            <1> 	and rax, 0xF 			; first digit is easy
   650 00000458 4989C0              <1> 	mov r8, rax 			; save running number
   651 0000045B 48C1EB04            <1> 	shr rbx, 4				; strip off 1st digit
   652                              <1> 
   653                              <1> .Loop1:
   654 0000045F 4883FB00            <1> 	cmp rbx, 0
   655 00000463 742A                <1> 	jz .Done
   656 00000465 4889D8              <1> 	mov rax, rbx
   657 00000468 4883E00F            <1> 	and rax, 0xF 			; strip off last digit
   658 0000046C 48F7E1              <1> 	mul rcx
   659 0000046F 4C01C0              <1> 	add rax, r8				; add to running total
   660 00000472 4989C0              <1> 	mov r8, rax 			; store in memory
   661                              <1> 
   662 00000475 4889C8              <1> 	mov rax, rcx
   663 00000478 B90A000000          <1> 	mov rcx, 0xA
   664 0000047D 48F7E1              <1> 	mul rcx
   665 00000480 4889C1              <1> 	mov rcx, rax 			; update multiplier
   666                              <1> 
   667 00000483 4831C0              <1> 	xor rax, rax
   668 00000486 4831D2              <1> 	xor rdx, rdx
   669 00000489 48C1EB04            <1> 	shr rbx, 4
   670 0000048D EBD0                <1> 	jmp .Loop1
   671                              <1> 
   672                              <1> .Done:
   673 0000048F 4C89C3              <1> 	mov rbx, r8				; move results back to EBX
   674                              <1> 
   675 00000492 4158                <1> 	pop r8
   676 00000494 5A                  <1> 	pop rdx
   677 00000495 59                  <1> 	pop rcx
   678 00000496 58                  <1> 	pop rax
   679 00000497 C3                  <1> ret
   680                              <1> ; Uses RCX as the parameter for intToHex.
   681                              <1> ;	IN:		RCX = original decimal number
   682                              <1> ;	OUT:	RCX = converted hex number
   683                              <1> IntToHex_rcx:
   684 00000498 53                  <1> 	push rbx
   685 00000499 4889CB              <1> 	mov rbx,rcx
   686 0000049C E8A0FFFFFF          <1> 	call IntToHex
   687 000004A1 4889D9              <1> 	mov rcx,rbx
   688 000004A4 5B                  <1> 	pop rbx
   689 000004A5 C3                  <1> ret
   690                              <1> 
   691                              <1> 
   692                              <1> 
   693                              <1> ;	This is call lets the user use EBX instead of EAX
   694                              <1> ;	IN:	RBX = number to convert
   695                              <1> ;	OUT:	---   this version does not return anything, not wasting EAX
   696                              <1> intToString_ebx:
   697                              <1> intToString_rbx:
   698 000004A6 50                  <1> 	push rax
   699 000004A7 4889D8              <1> 	mov rax, rbx
   700 000004AA E802000000          <1> 	call intToString
   701 000004AF 58                  <1> 	pop rax
   702 000004B0 C3                  <1> ret
   703                              <1> ;******************************************************************************
   704                              <1> ;	intToString
   705                              <1> ;		- converts an integer to a string, adds a NULL terminator (0) at the end.
   706                              <1> ;	param/		RAX = number to convert
   707                              <1> ;	param/		RDI = pointer location of buffer to put string
   708                              <1> ;	returns/	RAX = number of bytes written
   709                              <1> ;******************************************************************************
   710                              <1> intToString:
   711 000004B1 50                  <1> 	push rax
   712 000004B2 53                  <1> 	push rbx
   713 000004B3 51                  <1> 	push rcx
   714 000004B4 52                  <1> 	push rdx
   715 000004B5 57                  <1> 	push rdi
   716 000004B6 55                  <1> 	push rbp
   717                              <1> 
   718 000004B7 4889E5              <1> 	mov rbp, rsp
   719 000004BA B90A000000          <1> 	mov rcx, 10
   720                              <1> 
   721                              <1> .pushDigits:
   722 000004BF 4831D2              <1> 	xor rdx, rdx		; zero extend eax
   723 000004C2 48F7F1              <1> 	div rcx				; divide RAX by 10, RDX is now the next digit
   724 000004C5 4883C230            <1> 	add rdx, 0x30		; convert to ASCII digit
   725 000004C9 52                  <1> 	push rdx 			; push back onto stack and store it to be popped off
   726 000004CA 4885C0              <1> 	test rax, rax 		; remove leading zeros
   727 000004CD 75F0                <1> 	jnz .pushDigits
   728                              <1> 
   729                              <1> .popDigits:
   730 000004CF 58                  <1> 	pop rax
   731 000004D0 AA                  <1> 	stosb				; only write the lower byte, not the whole word
   732 000004D1 4839EC              <1> 	cmp rsp, rbp		; if RSP==RBP, all digits popped
   733 000004D4 75F9                <1> 	jne .popDigits
   734                              <1> 
   735 000004D6 4831C0              <1> 	xor rax, rax 		; add trailing NULL
   736 000004D9 AA                  <1> 	stosb
   737                              <1> 
   738 000004DA 4889F8              <1> 	mov rax, rdi
   739                              <1> 
   740 000004DD 5D                  <1> 	pop rbp
   741 000004DE 5F                  <1> 	pop rdi
   742 000004DF 5A                  <1> 	pop rdx
   743 000004E0 59                  <1> 	pop rcx
   744 000004E1 5B                  <1> 	pop rbx
   745                              <1> 	;pop rax
   746 000004E2 4883C408            <1> 	add rsp,8			; pop off original value of RAX
   747 000004E6 4829F8              <1> 	sub rax, rdi 		; return number of bytes written
   748 000004E9 C3                  <1> ret
   749                              <1> 
   750                              <1> 
   751                              <1> ; Same as intToString_incr below except it uses RBX instead of RAX
   752                              <1> ;	param/		RBX = number to convert
   753                              <1> ;	param/		RDI = pointer location of buffer to put string
   754                              <1> ;	returns/	RBX = number of bytes written
   755                              <1> intToString_incr_rbx:
   756 000004EA 50                  <1> 	push rax
   757 000004EB 4889D8              <1> 	mov rax,rbx
   758 000004EE E802000000          <1> 	call intToString_incr
   759 000004F3 58                  <1> 	pop rax
   760 000004F4 C3                  <1> ret
   761                              <1> ;******************************************************************************
   762                              <1> ;	intToString_incr
   763                              <1> ;		- Converts an integer to a string, adds a NULL terminator (0) at the end.
   764                              <1> ;		  Does not reset RDI back to starting position, leaves it where it is.
   765                              <1> ;	param/		RAX = number to convert
   766                              <1> ;	param/		RDI = pointer location of buffer to put string
   767                              <1> ;	returns/	RAX = number of bytes written
   768                              <1> ;******************************************************************************
   769                              <1> intToString_incr:
   770 000004F5 53                  <1> 	push rbx
   771 000004F6 51                  <1> 	push rcx
   772 000004F7 52                  <1> 	push rdx
   773 000004F8 55                  <1> 	push rbp
   774                              <1> 
   775 000004F9 57                  <1> 	push rdi 			; save starting point to stack
   776                              <1> 
   777 000004FA 89E5                <1> 	mov ebp, esp
   778 000004FC B90A000000          <1> 	mov ecx, 10
   779                              <1> 
   780                              <1> .pushDigits:
   781 00000501 31D2                <1> 	xor edx, edx		; zero extend eax
   782 00000503 F7F1                <1> 	div ecx				; divide EAX by 10, EDX is now the next digit
   783 00000505 83C230              <1> 	add edx, 30h		; convert to ASCII digit
   784 00000508 52                  <1> 	push rdx 			; push back onto stack and store it to be popped off
   785 00000509 85C0                <1> 	test eax, eax 		; remove leading zeros
   786 0000050B 75F4                <1> 	jnz .pushDigits
   787                              <1> 
   788                              <1> .popDigits:
   789 0000050D 58                  <1> 	pop rax
   790 0000050E AA                  <1> 	stosb				; only write the lower byte, not the whole word
   791 0000050F 39EC                <1> 	cmp esp, ebp		; if ESP==EBP, all digits popped
   792 00000511 75FA                <1> 	jne .popDigits
   793                              <1> 
   794 00000513 C60700              <1> 	mov byte [rdi], 0	; add trailing NULL
   795                              <1> 
   796 00000516 4889F8              <1> 	mov rax, rdi
   797 00000519 5B                  <1> 	pop rbx 			; pop original starting point
   798 0000051A 4829D8              <1> 	sub rax, rbx 		; calculate and return number of bytes written
   799                              <1> 
   800 0000051D 5D                  <1> 	pop rbp
   801 0000051E 5A                  <1> 	pop rdx
   802 0000051F 59                  <1> 	pop rcx
   803 00000520 5B                  <1> 	pop rbx
   804 00000521 C3                  <1> ret
   805                              <1> 
   806                              <1> 
   807                              <1> ;*******************************************************************************
   808                              <1> ; Get IP addresses, NICs 1 to 4.
   809                              <1> ; IN:	---
   810                              <1> ; OUT:	RAX = NIC1
   811                              <1> ;		RBX = NIC2
   812                              <1> ;		RCX = NIC3
   813                              <1> ;		RDX = NIC4
   814                              <1> ;*******************************************************************************
   815                              <1> net_get_ip:
   816 00000522 52                  <1> 	push rdx
   817 00000523 4831C0              <1> 	xor rax,rax 		; initialize reg's
   818 00000526 4831DB              <1> 	xor rbx,rbx 		;
   819 00000529 4831C9              <1> 	xor rcx,rcx 		;
   820 0000052C 4831D2              <1> 	xor rdx,rdx 		;
   821 0000052F BA1A000000          <1> 	mov rdx,0x1A		; get IP's
   822 00000534 CDFF                <1> 	int 0xFF
   823 00000536 5A                  <1> 	pop rdx
   824 00000537 C3                  <1> ret
   825                              <1> 
   826                              <1> ;*******************************************************************************
   827                              <1> ; Initializes memory to zeros.
   828                              <1> ; IN:	RAX = memory start
   829                              <1> ;		RCX = size, in bytes
   830                              <1> ;*******************************************************************************
   831                              <1> null_ram:
   832 00000538 50                  <1> 	push rax
   833 00000539 53                  <1> 	push rbx
   834 0000053A 51                  <1> 	push rcx
   835 0000053B 52                  <1> 	push rdx
   836 0000053C 57                  <1> 	push rdi
   837 0000053D 4150                <1> 	push r8 			; memory start
   838                              <1> 
   839 0000053F 4989C0              <1> 	mov r8,rax			; free up RAX
   840                              <1> 
   841 00000542 4889C8              <1> 	mov rax,rcx
   842 00000545 BB08000000          <1> 	mov rbx,8
   843 0000054A 4831D2              <1> 	xor rdx,rdx
   844 0000054D 48F7F3              <1> 	div rbx
   845 00000550 4889C1              <1> 	mov rcx,rax
   846 00000553 4C89C7              <1> 	mov rdi, r8
   847 00000556 4831C0              <1> 	xor rax,rax
   848 00000559 FC                  <1> 	cld
   849 0000055A F348AB              <1> 	rep stosq 			; NULL QWORDS
   850 0000055D 4889D1              <1> 	mov rcx,rdx
   851 00000560 F3AA                <1> 	rep stosb			; NULL remaining bytes
   852                              <1> 
   853 00000562 4158                <1> 	pop r8
   854 00000564 5F                  <1> 	pop rdi
   855 00000565 5A                  <1> 	pop rdx
   856 00000566 59                  <1> 	pop rcx
   857 00000567 5B                  <1> 	pop rbx
   858 00000568 58                  <1> 	pop rax
   859 00000569 C3                  <1> ret
   860                              <1> 
   861                              <1> 
   862                              <1> ;******************************************************************************
   863                              <1> ; Text mode or GUI mode print to X,Y location.
   864                              <1> ;
   865                              <1> ; This is the same as print_cli, except you can specify X,Y co-ordinates. In
   866                              <1> ; GUI mode; X will use character width * X and Y will use character height *
   867                              <1> ; Y.
   868                              <1> ; NOTE: This routine will not clear the screen. Programmer needs to figure out
   869                              <1> ;       when to do that.
   870                              <1> ;
   871                              <1> ; IN:	 AL = X
   872                              <1> ;		 AH = Y
   873                              <1> ;		RSI = pointer to string location
   874                              <1> ;******************************************************************************
   875                              <1> print_cli_xy:
   876 0000056A 52                  <1> 	push rdx
   877 0000056B BA00040000          <1> 	mov rdx,0x400
   878 00000570 CDFF                <1> 	int 0xFF
   879 00000572 5A                  <1> 	pop rdx
   880 00000573 C3                  <1> ret
   881                              <1> 
   882                              <1> 
   883                              <1> ;******************************************************************************
   884                              <1> ; Sames as print_cli_xy, except you can specify a color if in GUI mode.
   885                              <1> ; IN:	 AL = X
   886                              <1> ;		 AH = y
   887                              <1> ;		RSI = pointer to string location
   888                              <1> ;******************************************************************************
   889                              <1> print_cli_xy_clr:
   890 00000574 52                  <1> 	push rdx
   891 00000575 BA02040000          <1> 	mov rdx,0x402
   892 0000057A CDFF                <1> 	int 0xFF
   893 0000057C 5A                  <1> 	pop rdx
   894 0000057D C3                  <1> ret
   895                              <1> 
   896                              <1> ;******************************************************************************
   897                              <1> ; Same as print_cli_xy, except you specify number of characters to print.
   898                              <1> ; And the width (x coordinate).
   899                              <1> ; NOTE, this routine does not check if you are at the end of the screen.
   900                              <1> ; Or any other error checking, up to the programmer.
   901                              <1> ;
   902                              <1> ; IN:	 AL = X
   903                              <1> ;		 AH = Y
   904                              <1> ;		 BX = width
   905                              <1> ;		 CX = number of characters to print
   906                              <1> ;		RSI = pointer to string location
   907                              <1> ; OUT:	RAX = x/y coordinates
   908                              <1> ;******************************************************************************
   909                              <1> print_cli_xy_cw:
   910 0000057E 52                  <1> 	push rdx
   911 0000057F BA01040000          <1> 	mov rdx,0x401
   912 00000584 CDFF                <1> 	int 0xFF
   913 00000586 5A                  <1> 	pop rdx
   914 00000587 C3                  <1> ret
   915                              <1> 
   916                              <1> 
   917                              <1> ; Prints a NULL terminated string to the screen. This is the same as a console
   918                              <1> ; mode print routine. It will start at the beginning of the line and print
   919                              <1> ; the text.
   920                              <1> ;
   921                              <1> ; IN:	LINE_NO = Y coordinate
   922                              <1> ;		RSI = String to print
   923                              <1> print_ln:
   924 00000588 803C25[2E000000]00  <1> 	cmp byte [GUI],0
   925 00000590 752F                <1> 	jnz Print_gui
   926                              <1> 
   927 00000592 50                  <1> 	push rax
   928 00000593 6631C0              <1> 	xor ax,ax
   929                              <1> 
   930 00000596 66FF0425[37000000]  <1> 	inc word [LINE_NO]
   931                              <1> 
   932 0000059E 66833C25[37000000]- <1> 	cmp word [LINE_NO],21
   932 000005A6 15                  <1>
   933 000005A7 7205                <1> 	jb .End_clr_screen
   934 000005A9 E872FBFFFF          <1> 		call clear_screen
   935                              <1> 	.End_clr_screen:
   936 000005AE 53                  <1> 	push rbx
   937 000005AF 668B1C25[37000000]  <1> 	mov bx,[LINE_NO]
   938 000005B7 88DC                <1> 	mov ah,bl
   939 000005B9 5B                  <1> 	pop rbx
   940 000005BA E875000000          <1> 	call Print_txt
   941                              <1> 
   942 000005BF 58                  <1> 	pop rax
   943 000005C0 C3                  <1> ret
   944                              <1> 
   945                              <1> ; Prints a NULL terminated string in GUI mode
   946                              <1> ; IN:	LINE_NO = Y coordinate
   947                              <1> ;		RSI = null temrinated string
   948                              <1> Print_gui:
   949 000005C1 50                  <1> 	push rax
   950 000005C2 53                  <1> 	push rbx
   951 000005C3 51                  <1> 	push rcx
   952 000005C4 52                  <1> 	push rdx
   953                              <1> 
   954                              <1> 	; Check if end of screen
   955 000005C5 66833C25[37000000]- <1> 	cmp word [LINE_NO],21
   955 000005CD 15                  <1>
   956 000005CE 7205                <1> 	jb .Skip_clr_scr
   957 000005D0 E84BFBFFFF          <1> 		call clear_screen
   958                              <1> 	.Skip_clr_scr:
   959                              <1> 
   960                              <1> 
   961                              <1> ;	Parameters:	RDX = 0x121
   962                              <1> ;			AX = X coordinate
   963                              <1> ;			BX = Y coordinate
   964                              <1> ;			ECX = color
   965                              <1> ;			RSI = memory location of NULL terminated string
   966 000005D5 66B80500            <1> 	mov ax,5
   967 000005D9 E834000000          <1> 	call .Get_line_no			; returns to BX
   968 000005DE B900FF0000          <1> 	mov ecx, 0x00FF00
   969 000005E3 BA21010000          <1> 	mov rdx,0x121
   970 000005E8 CDFF                <1> 	int 0xFF
   971                              <1> 
   972 000005EA 66FF0425[37000000]  <1> 	inc word [LINE_NO]
   973                              <1> 
   974 000005F2 5A                  <1> 	pop rdx
   975 000005F3 59                  <1> 	pop rcx
   976 000005F4 5B                  <1> 	pop rbx
   977 000005F5 58                  <1> 	pop rax
   978 000005F6 C3                  <1> ret
   979                              <1> ; Returns the X coordinate for a character based on the current
   980                              <1> ; character counter CH_NUM. Then increments CH_NUM for next time.
   981                              <1> ; IN:	CH_NUM
   982                              <1> ; OUT:	AX = X coordinate
   983                              <1> 
   984                              <1> .Get_ch_no:
   985 000005F7 53                  <1> 	push rbx
   986 000005F8 52                  <1> 	push rdx
   987                              <1> 
   988 000005F9 4831D2              <1> 	xor rdx,rdx
   989 000005FC 668B0425[2C000000]  <1> 	mov ax,[CH_NUM]
   990 00000604 668B1C25[33000000]  <1> 	mov bx,[GUI_CH_W]
   991 0000060C 66F7E3              <1> 	mul bx
   992                              <1> 
   993 0000060F 5A                  <1> 	pop rdx
   994 00000610 5B                  <1> 	pop rbx
   995 00000611 C3                  <1> ret
   996                              <1> 
   997                              <1> ; Returns the BX value based on the current LINE_NO value.
   998                              <1> ; IN:	LINE_NO
   999                              <1> ; OUT:	BX = Y coordinate
  1000                              <1> .Get_line_no:
  1001 00000612 50                  <1> 	push rax
  1002 00000613 52                  <1> 	push rdx
  1003                              <1> 
  1004 00000614 4831C0              <1> 	xor rax,rax
  1005 00000617 4831DB              <1> 	xor rbx,rbx
  1006 0000061A 4831D2              <1> 	xor rdx,rdx
  1007                              <1> 
  1008 0000061D 668B0425[37000000]  <1> 	mov ax,[LINE_NO]
  1009 00000625 668B1C25[35000000]  <1> 	mov bx,[GUI_CH_H]
  1010 0000062D F7E3                <1> 	mul ebx
  1011                              <1> 
  1012 0000062F 89C3                <1> 	mov ebx,eax
  1013                              <1> 
  1014 00000631 5A                  <1> 	pop rdx
  1015 00000632 58                  <1> 	pop rax
  1016 00000633 C3                  <1> ret
  1017                              <1> 
  1018                              <1> 
  1019                              <1> ; Prints a NULL terminated string in text mode
  1020                              <1> ; IN:	 AL = X coordinate
  1021                              <1> ;		 AH = Y coordinate
  1022                              <1> ;		RSI = null terminated string
  1023                              <1> Print_txt:
  1024 00000634 52                  <1> 	push rdx
  1025 00000635 BA05030000          <1> 	mov rdx,0x305				; print string
  1026 0000063A CDFF                <1> 	int 0xFF
  1027 0000063C 5A                  <1> 	pop rdx
  1028 0000063D C3                  <1> ret
  1029                              <1> 
  1030                              <1> 
  1031                              <1> ;******************************************************************************
  1032                              <1> ; Relase memory from current user program. This does not give memory back to
  1033                              <1> ; the OS. It only deletes the entry(s) in the Page Tables.
  1034                              <1> ; IN:	RAX = memory location
  1035                              <1> ;		RCX = size in bytes to release
  1036                              <1> ;******************************************************************************
  1037                              <1> relmem:
  1038 0000063E 52                  <1> 	push rdx
  1039 0000063F BA23020000          <1> 	mov rdx,0x223
  1040 00000644 CDFF                <1> 	int 0xFF
  1041 00000646 5A                  <1> 	pop rdx
  1042 00000647 C3                  <1> ret
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ;******************************************************************************
  1046                              <1> ;	str_chomp
  1047                              <1> ;		- removes leading and trailing spaces
  1048                              <1> ;	param/		RAX = address pointer to string
  1049                              <1> ;******************************************************************************
  1050                              <1> str_chomp:
  1051 00000648 50                  <1> 	push rax
  1052 00000649 51                  <1> 	push rcx
  1053 0000064A 52                  <1> 	push rdx
  1054 0000064B 57                  <1> 	push rdi
  1055 0000064C 56                  <1> 	push rsi
  1056                              <1> 
  1057 0000064D 4889C2              <1> 	mov rdx, rax				; save string location
  1058                              <1> 
  1059 00000650 4889C7              <1> 	mov rdi, rax				; put location into RDI
  1060 00000653 B900000000          <1> 	mov rcx, 0					; space counter
  1061                              <1> 
  1062                              <1> .Count:							; get number of leading spaces
  1063 00000658 803F20              <1> 	cmp byte [rdi], ' '
  1064 0000065B 7508                <1> 	jne .Counted
  1065 0000065D 48FFC1              <1> 	inc rcx
  1066 00000660 48FFC7              <1> 	inc rdi
  1067 00000663 EBF3                <1> 	jmp .Count
  1068                              <1> 
  1069                              <1> .Counted:
  1070 00000665 4883F900            <1> 	cmp rcx, 0					; if no leading spaces
  1071 00000669 7416                <1> 	je  .Finished_copy
  1072                              <1> 
  1073 0000066B 4889FE              <1> 	mov rsi, rdi 				; address of first non-space
  1074 0000066E 4889D7              <1> 	mov rdi, rdx 				; reset to original start of string
  1075                              <1> 
  1076                              <1> .Copy_string:
  1077 00000671 8A06                <1> 	mov al, [rsi]				; copy to ESI to DSI
  1078 00000673 8807                <1> 	mov [rdi], al				; includes terminator
  1079 00000675 3C00                <1> 	cmp al, 0
  1080 00000677 7408                <1> 	je  .Finished_copy
  1081                              <1> 
  1082 00000679 48FFC6              <1> 	inc rsi
  1083 0000067C 48FFC7              <1> 	inc rdi
  1084 0000067F EBF0                <1> 	jmp .Copy_string
  1085                              <1> 
  1086                              <1> .Finished_copy:
  1087 00000681 4889D0              <1> 	mov rax, rdx 				; EAX = original string start
  1088 00000684 E88F010000          <1> 	call str_len
  1089 00000689 6683F800            <1> 	cmp ax, 0					; if string empty, then exit
  1090 0000068D 7413                <1> 	je  .Done
  1091                              <1> 
  1092 0000068F 4889D6              <1> 	mov rsi, rdx
  1093 00000692 4801C6              <1> 	add rsi, rax 				; move to end of string
  1094                              <1> 
  1095                              <1> .More:
  1096 00000695 48FFCE              <1> 	dec rsi
  1097 00000698 803E20              <1> 	cmp byte [rsi], ' '
  1098 0000069B 7505                <1> 	jne .Done
  1099 0000069D C60600              <1> 	mov byte [rsi], 0			; fill end spaces with NULL
  1100 000006A0 EBF3                <1> 	jmp .More					; first Zero is the string terminator
  1101                              <1> 
  1102                              <1> .Done:
  1103 000006A2 5E                  <1> 	pop rsi
  1104 000006A3 5F                  <1> 	pop rdi
  1105 000006A4 5A                  <1> 	pop rdx
  1106 000006A5 59                  <1> 	pop rcx
  1107 000006A6 58                  <1> 	pop rax
  1108 000006A7 C3                  <1>  ret
  1109                              <1> 
  1110                              <1> 
  1111                              <1>  ;******************************************************************************
  1112                              <1>  ;	str_cmp
  1113                              <1>  ;		- compares two zero terminated strings, if they are the same;
  1114                              <1>  ;		  returns 0 othrwise, return 1.
  1115                              <1>  ;	param/		RSI = pointer to source string
  1116                              <1>  ;	param/		RDI = pointer to destination string
  1117                              <1>  ;	returns/	 AL = 0 strings are the same, 1 strings are different
  1118                              <1>  ;******************************************************************************
  1119                              <1> str_cmp:
  1120 000006A8 53                  <1>  	push rbx
  1121 000006A9 57                  <1>  	push rdi
  1122 000006AA 56                  <1>  	push rsi
  1123                              <1> 
  1124                              <1>  .Loop1:
  1125 000006AB 8A06                <1>  	mov al, BYTE [rsi]
  1126 000006AD 8A1F                <1>  	mov bl, BYTE [rdi]
  1127                              <1> 
  1128 000006AF 3C00                <1>  	cmp al, 0					; end of string
  1129 000006B1 7410                <1>  	je  .Done
  1130                              <1> 
  1131 000006B3 38D8                <1> 	cmp al, bl
  1132 000006B5 7508                <1>  	jne .Not_the_same
  1133                              <1> 
  1134 000006B7 48FFC6              <1>  	inc rsi
  1135 000006BA 48FFC7              <1>  	inc rdi
  1136 000006BD EBEC                <1>  	jmp .Loop1
  1137                              <1> 
  1138                              <1>  .Not_the_same:
  1139 000006BF B001                <1>  	mov al, 1					; return code for strings are different
  1140 000006C1 EB02                <1> 	jmp .Exit
  1141                              <1> 
  1142                              <1>  .Done:
  1143 000006C3 30C0                <1>  	xor al,al					; return code for strings are equal
  1144                              <1> .Exit:
  1145 000006C5 5E                  <1>  	pop rsi
  1146 000006C6 5F                  <1>  	pop rdi
  1147 000006C7 5B                  <1>  	pop rbx
  1148 000006C8 C3                  <1>  ret
  1149                              <1> 
  1150                              <1> 
  1151                              <1> ;******************************************************************************
  1152                              <1> ;	str_cmp_ctr
  1153                              <1> ;		- compares two strings for a specified number of characters, if they are
  1154                              <1> ;		  the same; returns 0 othrwise, return 1.
  1155                              <1> ;	param/		RSI = pointer to source string
  1156                              <1> ;	param/		RDI = pointer to destination string
  1157                              <1> ;	param/		ECX = number of characters to check
  1158                              <1> ;	returns/	EAX = 0 strings are the same, 1 strings are different
  1159                              <1> ;******************************************************************************
  1160                              <1> str_cmp_ctr:
  1161 000006C9 53                  <1>  	push rbx
  1162 000006CA 51                  <1>  	push rcx
  1163 000006CB 57                  <1>  	push rdi
  1164 000006CC 56                  <1>  	push rsi
  1165                              <1> 
  1166                              <1> .Loop1:
  1167 000006CD 8A06                <1>  	mov al, BYTE [rsi]
  1168 000006CF 8A1F                <1>  	mov bl, BYTE [rdi]
  1169                              <1> 
  1170 000006D1 38D8                <1>  	cmp al, bl
  1171 000006D3 750F                <1>  	jne .Not_the_same
  1172                              <1> 
  1173 000006D5 48FFC6              <1>  	inc rsi
  1174 000006D8 48FFC7              <1>  	inc rdi
  1175 000006DB E2F0                <1>  	loop .Loop1
  1176                              <1> 
  1177 000006DD B800000000          <1>  	mov eax, 0					; return match found code
  1178 000006E2 EB05                <1>  	jmp .Done
  1179                              <1> 
  1180                              <1>  .Not_the_same:
  1181 000006E4 B801000000          <1>  	mov eax, 1					; return NO match found code
  1182                              <1> 
  1183                              <1>  .Done:
  1184 000006E9 5E                  <1>  	pop rsi
  1185 000006EA 5F                  <1>  	pop rdi
  1186 000006EB 59                  <1>  	pop rcx
  1187 000006EC 5B                  <1>  	pop rbx
  1188 000006ED C3                  <1>  ret
  1189                              <1> 
  1190                              <1> 
  1191                              <1> ;******************************************************************************
  1192                              <1> ;	str_cmp_nocase
  1193                              <1> ;		- Same as str_cmp, except this is case insensitive. It will compare
  1194                              <1> ;		  two strings, if they are the same, regardless of upper or lower case
  1195                              <1> ;		  letters. The Source string (RSI) MUST be zero terminated. The
  1196                              <1> ;		  destination string (RDI) doesn't matter if terminated or not.
  1197                              <1> ;		  returns 0 othrwise, return 1.
  1198                              <1> ;	param/		RSI = pointer to source string
  1199                              <1> ;	param/		RDI = pointer to destination string
  1200                              <1> ;	returns/	 AL = 0 strings are the same, 1 strings are different
  1201                              <1> ;******************************************************************************
  1202                              <1> str_cmp_nocase:
  1203 000006EE 53                  <1>     push rbx
  1204 000006EF 57                  <1>     push rdi
  1205 000006F0 56                  <1>     push rsi
  1206                              <1> 
  1207                              <1>  .Loop1:
  1208 000006F1 8A07                <1>     mov al, BYTE [rdi]
  1209 000006F3 E8BB010000          <1> 	call str_upper_ch
  1210 000006F8 88C3                <1> 	mov bl,al
  1211 000006FA 8A06                <1> 	mov al, BYTE [rsi]
  1212 000006FC E8B2010000          <1> 	call str_upper_ch
  1213                              <1> 
  1214 00000701 3C00                <1>     cmp al, 0					; end of string
  1215 00000703 7410                <1>     je  .Done
  1216                              <1> 
  1217 00000705 38D8                <1>     cmp al, bl
  1218 00000707 7508                <1>     jne .Not_the_same
  1219                              <1> 
  1220 00000709 48FFC6              <1>     inc rsi
  1221 0000070C 48FFC7              <1>     inc rdi
  1222 0000070F EBE0                <1>     jmp .Loop1
  1223                              <1> 
  1224                              <1>  .Not_the_same:
  1225 00000711 B001                <1>     mov al, 1					; return code for strings are different
  1226 00000713 EB02                <1>     jmp .Exit
  1227                              <1> 
  1228                              <1>  .Done:
  1229 00000715 30C0                <1>     xor al,al					; return code for strings are equal
  1230                              <1>  .Exit:
  1231 00000717 5E                  <1>     pop rsi
  1232 00000718 5F                  <1>     pop rdi
  1233 00000719 5B                  <1>     pop rbx
  1234 0000071A C3                  <1>  ret
  1235                              <1> 
  1236                              <1> 
  1237                              <1> ;******************************************************************************
  1238                              <1> ;	str_cpy
  1239                              <1> ;		- copies a string from one memory location to another, terminates at
  1240                              <1> ;		  NULL (0).
  1241                              <1> ;	param/		RSI = address pointer to source
  1242                              <1> ;	param/		RDI = address pointer to destination
  1243                              <1> ;******************************************************************************
  1244                              <1> str_cpy:
  1245 0000071B 50                  <1> 	push rax
  1246 0000071C 31C0                <1> 	xor  eax, eax
  1247                              <1> 
  1248                              <1> .Loop1:
  1249 0000071E 678A06              <1> 	mov al, BYTE [esi]
  1250 00000721 678807              <1> 	mov [edi], al
  1251 00000724 FFC6                <1> 	inc esi
  1252 00000726 FFC7                <1> 	inc edi
  1253 00000728 3C00                <1> 	cmp byte al, 0				; check for NULL
  1254 0000072A 75F2                <1> 	jne .Loop1
  1255                              <1> 
  1256                              <1> .Done:
  1257 0000072C 58                  <1> 	pop  rax
  1258 0000072D C3                  <1> ret
  1259                              <1> 
  1260                              <1> 
  1261                              <1> ;******************************************************************************
  1262                              <1> ; Basically the same as str_cpy except will terminate on either NULL or a
  1263                              <1> ; linefeed (0xA).
  1264                              <1> ;
  1265                              <1> ; IN:	RSI = address pointer to source
  1266                              <1> ; 		RDI = address pointer to destination
  1267                              <1> ;******************************************************************************
  1268                              <1> str_cpy_line:
  1269 0000072E 50                  <1> 	push rax
  1270 0000072F 4831C0              <1> 	xor  rax, rax
  1271                              <1> 
  1272                              <1> .Loop1:
  1273 00000732 AC                  <1> 	lodsb 						; load AL, inc RSI
  1274 00000733 AA                  <1> 	stosb 						; store to RDI, inc RDI
  1275 00000734 3C0A                <1> 	cmp byte al, 0xA 			; check for linefeed
  1276 00000736 7404                <1> 	je  .Done
  1277 00000738 3C00                <1> 	cmp byte al, 0				; check for NULL
  1278 0000073A 75F6                <1> 	jne .Loop1
  1279                              <1> 
  1280                              <1> .Done:
  1281 0000073C 58                  <1> 	pop  rax
  1282 0000073D C3                  <1> ret
  1283                              <1> 
  1284                              <1> 
  1285                              <1> ;******************************************************************************
  1286                              <1> ; Find a phrase within a string for a specified number of character.
  1287                              <1> ; IN:	RSI = memory pointer to NULL terminated source string
  1288                              <1> ;		RAX = NULL temrinated string to find
  1289                              <1> ;		RCX = number of characters to search
  1290                              <1> ; OUT:	RAX = location of found string. Zero if not found.
  1291                              <1> ;******************************************************************************
  1292                              <1> str_fnd_ctr:
  1293                              <1> 
  1294                              <1> 
  1295 0000073E C3                  <1> ret
  1296                              <1> 
  1297                              <1> ;******************************************************************************
  1298                              <1> ; Find and Replace.
  1299                              <1> ; Looks for characters in a string and replaces them with
  1300                              <1> ; another set of characters. NOTE: the string must be large enough if the
  1301                              <1> ; characters to replace with is larger then the characters replaced. That is,
  1302                              <1> ; RBX > RAX.
  1303                              <1> ;
  1304                              <1> ; IN:	RSI = memory pointer to NULL terminated source string
  1305                              <1> ;		RAX = NULL temrinated string to find
  1306                              <1> ;		RBX = NULL terminated string to replace with
  1307                              <1> ; OUT:	RSI = modified NULL terminated string
  1308                              <1> ;		RAX = -1 if there was no memory for result
  1309                              <1> ;******************************************************************************
  1310                              <1> str_fnd_n_rpl:
  1311 0000073F 53                  <1> 	push rbx		; pointer to original string
  1312 00000740 51                  <1> 	push rcx		; pointer to result string
  1313 00000741 52                  <1> 	push rdx
  1314 00000742 57                  <1> 	push rdi
  1315 00000743 56                  <1> 	push rsi
  1316 00000744 4150                <1> 	push r8			; string to find
  1317 00000746 4151                <1> 	push r9			; string to replace with
  1318 00000748 4152                <1> 	push r10 		; Result: location of temp mem
  1319 0000074A 4153                <1> 	push r11 		; size of temp mem
  1320 0000074C 4154                <1> 	push r12 		; original string
  1321                              <1> 
  1322 0000074E 50                  <1> 	push rax
  1323                              <1> 
  1324                              <1> 	; free up registers
  1325 0000074F 4989C0              <1> 	mov r8,rax
  1326 00000752 4989D9              <1> 	mov r9,rbx
  1327 00000755 4989F4              <1> 	mov r12,rsi
  1328                              <1> 
  1329                              <1> ; Calculate how much memory to allocate for result.
  1330 00000758 4D31DB              <1> 	xor r11,r11
  1331 0000075B 4C89C0              <1> 	mov rax,r8
  1332 0000075E E8B5000000          <1> 	call str_len
  1333 00000763 4889C1              <1> 	mov rcx,rax
  1334 00000766 4C89C8              <1> 	mov rax,r9
  1335 00000769 E8AA000000          <1> 	call str_len
  1336 0000076E 4839C8              <1> 	cmp rax,rcx
  1337 00000771 7606                <1> 	jbe .Allocate_mem	; if replace string is smaller or same size, allocate mem
  1338                              <1> 	; if larger, then get the difference
  1339 00000773 4829C8              <1> 	sub rax,rcx
  1340 00000776 4989C3              <1> 	mov r11,rax
  1341                              <1> 
  1342                              <1> ; Allocate temp memory to store result
  1343                              <1> .Allocate_mem:
  1344 00000779 4889F0              <1> 	mov rax,rsi
  1345 0000077C E897000000          <1> 	call str_len
  1346 00000781 4901C3              <1> 	add r11,rax 		; save size
  1347 00000784 BA21020000          <1> 	mov rdx,0x221
  1348 00000789 CDFF                <1> 	int 0xFF
  1349 0000078B 80FB00              <1> 	cmp bl,0
  1350 0000078E 757E                <1> 	jnz .Err1
  1351 00000790 4989C2              <1> 	mov r10,rax			; save temp mem location
  1352                              <1> 
  1353                              <1> ; Find and Replace
  1354 00000793 4889F3              <1> 	mov rbx,rsi			; pointer original string
  1355 00000796 4C89D1              <1> 	mov rcx,r10			; pointer result string
  1356 00000799 4C89C7              <1> 	mov rdi,r8			; string to find
  1357                              <1> 
  1358                              <1> 	.Search:
  1359                              <1> 	; RDI = string to find
  1360                              <1> 	; RSI = original string
  1361 0000079C 8A07                <1> 		mov al,[rdi]
  1362 0000079E 3C00                <1> 		cmp al,0		; check if end of string to find
  1363 000007A0 7411                <1> 		jz .Found		; if so, a match was found
  1364 000007A2 803E00              <1> 		cmp byte [rsi],0; check if end of original string
  1365 000007A5 743A                <1> 		je .End
  1366 000007A7 3A06                <1> 		cmp al,[rsi]	; compare string to find with original string
  1367 000007A9 751D                <1> 		jne .No_match
  1368 000007AB 48FFC6              <1> 		inc rsi
  1369 000007AE 48FFC7              <1> 		inc rdi
  1370 000007B1 EBE9                <1> 		jmp .Search
  1371                              <1> 
  1372                              <1> 	.Found:
  1373                              <1> 		; If match found, replace it in temp mem
  1374 000007B3 4889F3              <1> 		mov rbx,rsi 	; save pointer to original string
  1375 000007B6 48FFCB              <1> 		dec rbx
  1376 000007B9 4C89CE              <1> 		mov rsi,r9		; string to replace with
  1377                              <1> 
  1378                              <1> 	.Replace:
  1379 000007BC AC                  <1> 		lodsb
  1380 000007BD 3C00                <1> 		cmp al,0
  1381 000007BF 7412                <1> 		je .Next
  1382 000007C1 8801                <1> 		mov [rcx],al
  1383 000007C3 48FFC1              <1> 		inc rcx
  1384 000007C6 EBF4                <1> 		jmp .Replace
  1385                              <1> 
  1386                              <1> 	.No_match:
  1387 000007C8 4889DE              <1> 		mov rsi,rbx 	; current location of original
  1388 000007CB 4889CF              <1> 		mov rdi,rcx 	; current location of result
  1389 000007CE AC                  <1> 		lodsb
  1390 000007CF AA                  <1> 		stosb
  1391 000007D0 48FFC1              <1> 		inc rcx 		; move result pointer
  1392                              <1> 
  1393                              <1> 	.Next:
  1394 000007D3 4C89C7              <1> 		mov rdi,r8
  1395 000007D6 48FFC3              <1> 		inc rbx 		; move pointer to original
  1396 000007D9 4889DE              <1> 		mov rsi,rbx
  1397 000007DC 803E00              <1> 		cmp byte [rsi],0
  1398 000007DF 75BB                <1> 		jne .Search
  1399                              <1> 
  1400                              <1> 	.End:
  1401 000007E1 C60100              <1> 		mov byte [rcx],0
  1402                              <1> 
  1403                              <1> ; Copy result back to original string.
  1404 000007E4 4C89D6              <1> 	mov rsi,r10			; result string
  1405 000007E7 4C89E7              <1> 	mov rdi,r12			; oritinal string
  1406                              <1> 	.Loop_copy:
  1407 000007EA AC                  <1> 		lodsb
  1408 000007EB AA                  <1> 		stosb
  1409 000007EC 3C00                <1> 		cmp al,0
  1410 000007EE 75FA                <1> 	jnz .Loop_copy
  1411                              <1> 
  1412                              <1> 
  1413                              <1> .Deallocate_mem:
  1414 000007F0 4C89D0              <1> 	mov rax,r10
  1415 000007F3 4C89D9              <1> 	mov rcx,r11
  1416 000007F6 BA22020000          <1> 	mov rdx,0x222
  1417 000007FB CDFF                <1> 	int 0xFF
  1418                              <1> 
  1419 000007FD 58                  <1> 	pop rax
  1420                              <1> 
  1421                              <1> .Done:
  1422 000007FE 415C                <1> 	pop r12
  1423 00000800 415B                <1> 	pop r11
  1424 00000802 415A                <1> 	pop r10
  1425 00000804 4159                <1> 	pop r9
  1426 00000806 4158                <1> 	pop r8
  1427 00000808 5E                  <1> 	pop rsi
  1428 00000809 5F                  <1> 	pop rdi
  1429 0000080A 5A                  <1> 	pop rdx
  1430 0000080B 59                  <1> 	pop rcx
  1431 0000080C 5B                  <1> 	pop rbx
  1432 0000080D C3                  <1> ret
  1433                              <1> .Err1:
  1434 0000080E 58                  <1> 	pop rax
  1435 0000080F 48C7C0FFFFFFFF      <1> 	mov rax,-1
  1436 00000816 EBE6                <1> 	jmp .Done
  1437                              <1> 
  1438                              <1> 
  1439                              <1> ;******************************************************************************
  1440                              <1> ;	str_len
  1441                              <1> ;		- determines the length of a string
  1442                              <1> ;	param/		RAX = address pointer to string
  1443                              <1> ;	returns/	RAX = length
  1444                              <1> ;******************************************************************************
  1445                              <1> str_len:
  1446 00000818 53                  <1> 	push rbx
  1447 00000819 51                  <1> 	push rcx
  1448                              <1> 
  1449 0000081A 4889C3              <1> 	mov rbx, rax
  1450 0000081D B900000000          <1> 	mov rcx, 0					; initialize counter
  1451                              <1> 
  1452                              <1> .Continue:
  1453 00000822 803B00              <1> 	cmp byte [rbx], 0			; end of string check
  1454 00000825 7408                <1> 	je  .Done
  1455 00000827 48FFC3              <1> 	inc rbx
  1456 0000082A 48FFC1              <1> 	inc rcx
  1457 0000082D EBF3                <1> 	jmp .Continue
  1458                              <1> 
  1459                              <1> .Done:
  1460 0000082F 4889C8              <1> 	mov rax, rcx
  1461                              <1> 
  1462 00000832 59                  <1> 	pop rcx
  1463 00000833 5B                  <1> 	pop rbx
  1464 00000834 C3                  <1> ret
  1465                              <1> 
  1466                              <1> 
  1467                              <1> ;******************************************************************************
  1468                              <1> ; Splits a string into 2 based on a specified character. The routine will
  1469                              <1> ; search for the first instance of the specified character. It will then
  1470                              <1> ; return the source memory pointer as well as a second pointer of the same string.
  1471                              <1> ; It will terminate the strings and remove leading zeros.
  1472                              <1> ;
  1473                              <1> ; IN:	RSI = source string
  1474                              <1> ;		 BL = character to split on
  1475                              <1> ; OUT:	RSI = memory location for first string; zero terminated, tailing spaces removed
  1476                              <1> ;		RDI = memory location for second string; zero terminated, leading/trailing spaces removed.
  1477                              <1> ;		      If match unsucessful, RDI=0.
  1478                              <1> ;******************************************************************************
  1479                              <1> str_split:
  1480 00000835 50                  <1> 	push rax
  1481 00000836 56                  <1> 	push rsi 						; save starting location
  1482 00000837 4831FF              <1> 	xor rdi,rdi
  1483                              <1> 
  1484                              <1> .Loop1:
  1485 0000083A 803E00              <1> 	cmp [rsi], byte 0x0				; if reached the end, then exit
  1486 0000083D 7429                <1> 	jz  .End_of_string
  1487                              <1> 
  1488 0000083F 3A1E                <1> 	cmp bl, byte [rsi]
  1489 00000841 7502                <1> 	jne .No_match
  1490 00000843 EB05                <1> 	jmp .Match_found
  1491                              <1> 
  1492                              <1> .No_match:
  1493 00000845 48FFC6              <1> 	inc rsi
  1494 00000848 EBF0                <1> 	jmp .Loop1
  1495                              <1> 
  1496                              <1> .Match_found:
  1497 0000084A 4889F7              <1> 	mov rdi, rsi 					; set starting point for second string
  1498 0000084D 48FFC7              <1> 	inc rdi 						;
  1499                              <1> 
  1500                              <1> 	;	remove trailing spaces and set NULL terminator
  1501 00000850 C60600              <1> 	mov [rsi], byte 0x0 			; replace split char with NULL
  1502 00000853 4889F0              <1> 	mov rax, rsi
  1503 00000856 E8EDFDFFFF          <1> 	call str_chomp 					; remove any trailing spaces
  1504                              <1> 
  1505                              <1> 	;push rsi 						; save string 1 starting position for now, RSI used in next call
  1506 0000085B 4889F8              <1> 	mov rax, rdi
  1507                              <1> 	;mov rsi, rdi
  1508 0000085E E8E5FDFFFF          <1> 	call str_chomp
  1509 00000863 4889C7              <1> 	mov rdi, rax
  1510                              <1> 	;mov rdi, rsi
  1511                              <1> 
  1512                              <1> 	;pop rsi
  1513 00000866 EB03                <1> 	jmp .Done
  1514                              <1> 
  1515                              <1> .End_of_string:
  1516 00000868 4831FF              <1> 	xor rdi,rdi 				; return zero, not found
  1517                              <1> 
  1518                              <1> .Done:
  1519 0000086B 5E                  <1> 	pop rsi 					; restore starting location
  1520 0000086C 58                  <1> 	pop rax
  1521 0000086D C3                  <1> ret
  1522                              <1> 
  1523                              <1> 
  1524                              <1> ;******************************************************************************
  1525                              <1> ; Same idea as str_split except instead of looking for the character to split
  1526                              <1> ; on from left to right, this routine goes in the opposite direction; right
  1527                              <1> ; to left.
  1528                              <1> ;
  1529                              <1> ; IN:	RSI = source string
  1530                              <1> ;		 BL = character to split on
  1531                              <1> ; OUT:	RSI = memory location for first string; zero terminated, tailing spaces removed
  1532                              <1> ;		RDI = memory location for second string; zero terminated, leading/trailing spaces removed.
  1533                              <1> ;		      If match unsucessful, RDI=0.
  1534                              <1> ;******************************************************************************
  1535                              <1> str_split_r:
  1536 0000086E 50                  <1> 	push rax
  1537 0000086F 51                  <1> 	push rcx
  1538 00000870 56                  <1> 	push rsi
  1539                              <1> 
  1540 00000871 4889F0              <1> 	mov rax,rsi 				; get length of string
  1541 00000874 E89FFFFFFF          <1> 	call str_len
  1542 00000879 4883F800            <1> 	cmp rax,0
  1543 0000087D 740E                <1> 	jz .No_match 				; no string to check, exit with RDI=0
  1544                              <1> 
  1545 0000087F 4889C1              <1> 	mov rcx,rax
  1546                              <1> .Loop1:
  1547 00000882 3A1C0E              <1> 	cmp bl, [rsi+rcx]
  1548 00000885 740B                <1> 	je .Match
  1549 00000887 E2F9                <1> 	loop .Loop1
  1550                              <1> 
  1551                              <1> ; Becuase RCX=0 is not checked in loop above, drops out before that, we
  1552                              <1> ; need to do one more check.
  1553 00000889 3A1E                <1> 	cmp bl, [rsi]
  1554 0000088B 7405                <1> 	je .Match
  1555                              <1> 
  1556                              <1> .No_match:
  1557 0000088D 4831FF              <1> 	xor rdi,rdi
  1558 00000890 EB1D                <1> 	jmp .Done
  1559                              <1> 
  1560                              <1> .Match:
  1561 00000892 C6040E00            <1> 	mov byte [rsi+rcx], 0x00	; replace seperator with NULL
  1562 00000896 48FFC1              <1> 	inc rcx
  1563 00000899 4801F1              <1> 	add rcx, rsi
  1564 0000089C 4889CF              <1> 	mov rdi, rcx
  1565 0000089F 4889F0              <1> 	mov rax, rsi
  1566 000008A2 E8A1FDFFFF          <1> 	call str_chomp 				; remove leading and trailing spaces
  1567 000008A7 4889F8              <1> 	mov rax, rdi
  1568 000008AA E899FDFFFF          <1> 	call str_chomp
  1569                              <1> 
  1570                              <1> .Match_at_char0:
  1571                              <1> 
  1572                              <1> 
  1573                              <1> .Done:
  1574 000008AF 5E                  <1> 	pop rsi
  1575 000008B0 59                  <1> 	pop rcx
  1576 000008B1 58                  <1> 	pop rax
  1577 000008B2 C3                  <1> ret
  1578                              <1> 
  1579                              <1> 
  1580                              <1> ;******************************************************************************
  1581                              <1> ;	str_upper_ch
  1582                              <1> ; 		- Converts a character to upper case
  1583                              <1> ;
  1584                              <1> ; 	IN:		AL = character to convert
  1585                              <1> ; 	OUT:	AL = return character, unchaged if not in a-z range
  1586                              <1> ;******************************************************************************
  1587                              <1> str_upper_ch:
  1588                              <1>    ;	Check if character is in the range of a-z. If not, then return
  1589                              <1>    ;	character unchanged.
  1590 000008B3 3C61                <1>    cmp al, 'a'
  1591 000008B5 7206                <1>    jb .Done
  1592 000008B7 3C7A                <1>    cmp al, 'z'
  1593 000008B9 7702                <1>    ja .Done
  1594 000008BB 2C20                <1>    sub al, 0x20
  1595                              <1> .Done:
  1596 000008BD C3                  <1> ret
  1597                              <1> 
  1598                              <1> 
  1599                              <1> ;******************************************************************************
  1600                              <1> ; Clear TCP signalling header
  1601                              <1> ; IN:	RCV_BUFF
  1602                              <1> ; OUT:	---
  1603                              <1> ;******************************************************************************
  1604                              <1> tcp_clear_sig:
  1605                              <1> ;	push rax
  1606                              <1> ;	push rcx
  1607                              <1> ;	push rdx
  1608 000008BE 57                  <1> 	push rdi
  1609                              <1> 
  1610                              <1> ;	mov rax,TCP_SIG_HDR_Size
  1611                              <1> ;	mov rcx,8
  1612                              <1> ;	xor rdx,rdx
  1613                              <1> ;	div ecx
  1614                              <1> ;	mov ecx,eax
  1615                              <1> 
  1616                              <1> 	; Clear signalling bytes in NET_BUFF
  1617                              <1> ;	xor rax,rax
  1618 000008BF 488B3C25[51000000]  <1> 	mov rdi,[RCV_BUFF]
  1619                              <1> ;	cld
  1620                              <1> ;	rep stosq
  1621                              <1> 
  1622 000008C7 66C7070000          <1> 	mov word [rdi],0
  1623                              <1> 
  1624 000008CC 5F                  <1> 	pop rdi
  1625                              <1> ;	pop rdx
  1626                              <1> ;	pop rcx
  1627                              <1> ;	pop rax
  1628 000008CD C3                  <1> ret
  1629                              <1> 
  1630                              <1> 
  1631                              <1> ;******************************************************************************
  1632                              <1> ; Closes a TCP connection.
  1633                              <1> ; IN:	RCX = connection ID
  1634                              <1> ; OUT:	RAX = network module response code
  1635                              <1> ;******************************************************************************
  1636                              <1> tcp_close:
  1637 000008CE 52                  <1> 	push rdx
  1638 000008CF BA27000000          <1> 	mov rdx,0x27
  1639 000008D4 CDFF                <1> 	int 0xFF
  1640 000008D6 5A                  <1> 	pop rdx
  1641 000008D7 C3                  <1> ret
  1642                              <1> 
  1643                              <1> ;******************************************************************************
  1644                              <1> ; Closes a TCP connection, does not wait for a response.
  1645                              <1> ; IN:	RCX = connection ID
  1646                              <1> ; OUT:	RAX = network module response code
  1647                              <1> ;******************************************************************************
  1648                              <1> tcp_close_nw:
  1649 000008D8 52                  <1> 	push rdx
  1650 000008D9 BA26000000          <1> 	mov rdx,0x26
  1651 000008DE CDFF                <1> 	int 0xFF
  1652 000008E0 5A                  <1> 	pop rdx
  1653 000008E1 C3                  <1> ret
  1654                              <1> 
  1655                              <1> ;******************************************************************************
  1656                              <1> ; Closes a TCP connection using STP.
  1657                              <1> ; IN:	RCX = connection ID
  1658                              <1> ; OUT:	RAX = return code
  1659                              <1> ;******************************************************************************
  1660                              <1> tcp_close_stp:
  1661 000008E2 52                  <1> 	push rdx
  1662 000008E3 56                  <1> 	push rsi
  1663                              <1> 
  1664 000008E4 4831C0              <1> 	xor rax,rax					; set 0 bytes to send, this will flag to do a close only
  1665 000008E7 4831F6              <1> 	xor rsi,rsi
  1666 000008EA 53                  <1> 	push rbx
  1667                              <1> 		; set close flag
  1668 000008EB BB01000000          <1> 		mov rbx,1
  1669 000008F0 48C1E320            <1> 		shl rbx,32
  1670 000008F4 4809D8              <1> 		or rax,rbx
  1671 000008F7 5B                  <1> 	pop rbx
  1672                              <1> 
  1673 000008F8 BA2F000000          <1> 	mov rdx, 0x2F				; Send TCP data
  1674 000008FD CDFF                <1> 	int 0xFF
  1675                              <1> 
  1676 000008FF 5E                  <1> 	pop rsi
  1677 00000900 5A                  <1> 	pop rdx
  1678 00000901 C3                  <1> ret
  1679                              <1> 
  1680                              <1> ;******************************************************************************
  1681                              <1> ; Opens a TCP listener port using common variables
  1682                              <1> ; IN:	PORT
  1683                              <1> ;		RCV_BUFF
  1684                              <1> ;		RCV_BUFF_SZ
  1685                              <1> ; OUT:	RAX = return code; 0=success, refer to NET_RTN_ codes
  1686                              <1> ;		[CID] = connection ID
  1687                              <1> ;		RCX   = connection ID
  1688                              <1> ;******************************************************************************
  1689                              <1> tcp_listener:
  1690 00000902 52                  <1> 	push rdx
  1691 00000903 57                  <1> 	push rdi
  1692                              <1> 
  1693 00000904 480FB70425-         <1> 	movzx rax, word [PORT]
  1693 00000909 [4F000000]          <1>
  1694 0000090D 8B0C25[59000000]    <1> 	mov ecx,[RCV_BUFF_SZ]
  1695                              <1> ;	mov rdi,[RCV_BUFF]				; not used anymore
  1696 00000914 BA30000000          <1> 	mov rdx,0x30
  1697 00000919 CDFF                <1> 	int 0xFF
  1698 0000091B 4883F800            <1> 	cmp rax,0
  1699 0000091F 7508                <1> 	jnz .Done
  1700 00000921 48890C25[47000000]  <1> 	mov [CID],rcx
  1701                              <1> .Done:
  1702 00000929 5F                  <1> 	pop rdi
  1703 0000092A 5A                  <1> 	pop rdx
  1704                              <1> 
  1705 0000092B 4883F800            <1> 	cmp rax,0
  1706 0000092F 0F85B9F7FFFF        <1> 	jnz Error_open_port
  1707 00000935 C3                  <1> ret
  1708                              <1> 
  1709                              <1> 
  1710                              <1> ;******************************************************************************
  1711                              <1> ; TCP Send. Sends data through and existing connection.
  1712                              <1> ; IN:	RCX = connection ID
  1713                              <1> ;		EAX = send buffer size
  1714                              <1> ;		RSI = virtual address of send buffer
  1715                              <1> ; OUT:	RAX = return code
  1716                              <1> ;******************************************************************************
  1717                              <1> tcp_send:
  1718 00000936 52                  <1> 	push rdx
  1719 00000937 BA28000000          <1> 	mov rdx, 0x28				; Send TCP data
  1720 0000093C CDFF                <1> 	int 0xFF
  1721 0000093E 5A                  <1> 	pop rdx
  1722 0000093F C3                  <1> ret
  1723                              <1> 
  1724                              <1> ;******************************************************************************
  1725                              <1> ; TCP Send. Sends data through an existing connection.
  1726                              <1> ; IN:	RCX = connection ID
  1727                              <1> ;		EAX = send buffer size
  1728                              <1> ;		RSI = virtual address of send buffer
  1729                              <1> ; OUT:	RAX = return code
  1730                              <1> ;******************************************************************************
  1731                              <1> tcp_sendq:
  1732 00000940 52                  <1> 	push rdx
  1733 00000941 BA2B000000          <1> 	mov rdx, 0x2B				; Send TCP data
  1734 00000946 CDFF                <1> 	int 0xFF
  1735 00000948 5A                  <1> 	pop rdx
  1736 00000949 C3                  <1> ret
  1737                              <1> 
  1738                              <1> ;******************************************************************************
  1739                              <1> ; TCP Send using the Send TCP Packet program. This spawns a new user program
  1740                              <1> ; so that the current program doesn't have to wait for a response.
  1741                              <1> ; Sends data through and existing connection.
  1742                              <1> ; IN:	RCX = connection ID
  1743                              <1> ;		EAX = send buffer size & flags
  1744                              <1> ;		RSI = virtual address of send buffer
  1745                              <1> ; OUT:	RAX = return code
  1746                              <1> ;******************************************************************************
  1747                              <1> tcp_send_stp:
  1748 0000094A 52                  <1> 	push rdx
  1749 0000094B BA2F000000          <1> 	mov rdx, 0x2F				; Send TCP data
  1750 00000950 CDFF                <1> 	int 0xFF
  1751 00000952 5A                  <1> 	pop rdx
  1752 00000953 C3                  <1> ret
  1753                              <1> 
  1754                              <1> ; This is the same as tcp_send_stp except it signals STP to close the
  1755                              <1> ; conection when the send is completed.
  1756                              <1> tcp_send_stp_c:
  1757 00000954 50                  <1> 	push rax
  1758 00000955 52                  <1> 	push rdx
  1759                              <1> 
  1760 00000956 53                  <1> 	push rbx
  1761 00000957 BB01000000          <1> 		mov rbx,1
  1762 0000095C 48C1E320            <1> 		shl rbx,32
  1763 00000960 4809D8              <1> 		or rax,rbx
  1764 00000963 5B                  <1> 	pop rbx
  1765                              <1> 
  1766 00000964 BA2F000000          <1> 	mov rdx, 0x2F				; Send TCP data
  1767 00000969 CDFF                <1> 	int 0xFF
  1768 0000096B 5A                  <1> 	pop rdx
  1769 0000096C 58                  <1> 	pop rax
  1770 0000096D C3                  <1> ret
  1771                              <1> 
  1772                              <1> ;******************************************************************************
  1773                              <1> ; Returns number of seconds the system has been running.
  1774                              <1> ; IN:	---
  1775                              <1> ; OUT:	RAX = seconds
  1776                              <1> ;******************************************************************************
  1777                              <1> uptime_s:
  1778                              <1> uptime_seconds:
  1779 0000096E 53                  <1> 	push rbx
  1780 0000096F 52                  <1> 	push rdx
  1781                              <1> 
  1782 00000970 BA0D000000          <1> 	mov rdx,0x0D
  1783 00000975 CDFF                <1> 	int 0xFF
  1784 00000977 BBE8030000          <1> 	mov rbx,1000
  1785 0000097C 4831D2              <1> 	xor rdx,rdx
  1786 0000097F 48F7F3              <1> 	div rbx
  1787                              <1> 
  1788 00000982 5A                  <1> 	pop rdx
  1789 00000983 5B                  <1> 	pop rbx
  1790 00000984 C3                  <1> ret
  1791                              <1> 
  1792                              <1> ;******************************************************************************
  1793                              <1> ; Waits for a period of time. This routine will not sit in a busy wait and
  1794                              <1> ; will switch to another process until the time period expires.
  1795                              <1> ; IN:	RCX = how long to wait, in milliseconds (i.e. 1000 = 1 sec)
  1796                              <1> ; OUT:	---
  1797                              <1> ;******************************************************************************
  1798                              <1> waitms:
  1799 00000985 50                  <1> 	push rax
  1800 00000986 51                  <1> 	push rcx
  1801 00000987 52                  <1> 	push rdx
  1802                              <1> 
  1803                              <1> 	; Get current ms
  1804 00000988 BA0D000000          <1> 	mov rdx,0xD
  1805 0000098D CDFF                <1> 	int 0xFF
  1806                              <1> ;	mov rcx,rax
  1807 0000098F 4801C1              <1> 	add rcx,rax
  1808                              <1> 	wait_loop:
  1809 00000992 BA0F000000          <1> 		mov edx, 0xF
  1810 00000997 CDFF                <1> 		int 0xFF
  1811 00000999 BA0D000000          <1> 		mov rdx, 0xD
  1812 0000099E CDFF                <1> 		int 0xFF
  1813 000009A0 4839C8              <1> 		cmp rax,rcx
  1814 000009A3 76ED                <1> 	jbe wait_loop
  1815                              <1> 
  1816 000009A5 5A                  <1> 	pop rdx
  1817 000009A6 59                  <1> 	pop rcx
  1818 000009A7 58                  <1> 	pop rax
  1819 000009A8 C3                  <1> ret
  1820                              <1> 
  1821                              <1> ; Locks process
  1822                              <1> xl:
  1823 000009A9 50                  <1> 	push rax
  1824 000009AA 52                  <1> 	push rdx
  1825                              <1> 
  1826 000009AB 66B80100            <1> 	mov ax,1
  1827 000009AF BAFFFF0000          <1> 	mov rdx,0xFFFF
  1828 000009B4 CDFF                <1> 	int 0xFF
  1829                              <1> 
  1830 000009B6 5A                  <1> 	pop rdx
  1831 000009B7 58                  <1> 	pop rax
  1832 000009B8 C3                  <1> ret
  1833                              <1> 
  1834                              <1> ; Unlocks process
  1835                              <1> xul:
  1836 000009B9 50                  <1> 	push rax
  1837 000009BA 52                  <1> 	push rdx
  1838                              <1> 
  1839 000009BB 66B80000            <1> 	mov ax,0
  1840 000009BF BAFFFF0000          <1> 	mov rdx,0xFFFF
  1841 000009C4 CDFF                <1> 	int 0xFF
  1842                              <1> 
  1843 000009C6 5A                  <1> 	pop rdx
  1844 000009C7 58                  <1> 	pop rax
  1845 000009C8 C3                  <1> ret
    29                                  
    30                                  
    31                                  ENTRY:
    32 000009C9 4883C408                add rsp,8
    33 000009CD E849F9FFFF              call gui_init
    34                                  
    35                                  ; set initial values
    36 000009D2 480FB70425-             movzx rax, word [GUI_X]
    36 000009D7 [2F000000]         
    37 000009DB BB02000000              mov rbx, 2
    38 000009E0 F7F3                    div ebx
    39 000009E2 66890425[14000000]      mov [start_x],ax
    40 000009EA 66890425[0B000000]      mov [x],ax
    41                                  
    42 000009F2 480FB70425-             movzx rax, word [GUI_Y]
    42 000009F7 [31000000]         
    43 000009FB F7F3                    div ebx
    44 000009FD 66890425[0D000000]      mov word [y],ax
    45 00000A05 66890425[16000000]      mov word [start_y],ax
    46 00000A0D 668B0425[31000000]      mov ax, [GUI_Y]
    47 00000A15 6683E819                sub ax, 25
    48 00000A19 66890425[10000000]      mov [floor],ax
    49                                  
    50                                  main_loop:
    51 00000A21 E818000000                  call draw_char
    52 00000A26 E89D000000                  call wait_time
    53 00000A2B E807000000                  call clear_char
    54 00000A30 E82C000000                  call move
    55 00000A35 EBEA                    jmp main_loop
    56                                  
    57                                  ;*******************************************************************************
    58                                  ;*  PROCEDURES
    59                                  ;*******************************************************************************
    60                                  clear_char:
    61 00000A37 B900000000                  mov ecx,0
    62 00000A3C EB05                        jmp draw
    63                                  
    64                                  draw_char:
    65 00000A3E B9EE675400                  mov ecx,0x5467EE
    66                                  
    67                                  draw:
    68 00000A43 668B0425[0B000000]          mov ax,[x]
    69 00000A4B 668B1C25[0D000000]          mov bx,[y]
    70 00000A53 41BA6F000000                mov r10, 'o'
    71 00000A59 BA20010000                  mov rdx, 0x120
    72                                  
    73                                  ;    Draw a character
    74                                  ;    Parameters:
    75                                  ;       RDX = 0x120
    76                                  ;		AX = X coordinate
    77                                  ;		BX = Y coordinate
    78                                  ;		ECX = color
    79                                  ;		R10 = character code
    80 00000A5E CDFF                        int 0xFF
    81 00000A60 C3                      ret
    82                                  
    83                                  move:
    84 00000A61 803C25[0F000000]00          cmp byte [direction],0
    85 00000A69 742A                        jz .going_up
    86                                  
    87                                  .going_down:
    88 00000A6B 668B0425[0D000000]          mov ax,[y]
    89 00000A73 66030425[12000000]          add ax,[move_rate]
    90 00000A7B 663B0425[10000000]          cmp ax,[floor]
    91 00000A83 7C3A                        jl .Done
    92                                  
    93 00000A85 668B0425[10000000]          mov ax,[floor]
    94 00000A8D 803425[0F000000]01          xor byte [direction],1
    95                                  
    96                                  .going_up:
    97 00000A95 668B0425[0D000000]          mov ax, [y]
    98 00000A9D 662B0425[12000000]          sub ax, [move_rate]
    99 00000AA5 663B0425[16000000]          cmp ax, [start_y]
   100 00000AAD 7F10                        jg .Done
   101                                  
   102 00000AAF 668B0425[16000000]          mov ax, [start_y]
   103 00000AB7 803425[0F000000]01          xor byte [direction],1
   104                                  
   105                                  .Done:
   106 00000ABF 66890425[0D000000]          mov [y],ax
   107 00000AC7 C3                      ret
   108                                  
   109                                  
   110                                  wait_time:
   111 00000AC8 488B0C25[18000000]          mov rcx,[wait_time_ms]
   112 00000AD0 E8B0FEFFFF                  call waitms
   113 00000AD5 C3                      ret
